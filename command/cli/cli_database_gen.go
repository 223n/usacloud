// Code generated by 'github.com/sacloud/usacloud/tools/gen-cli-commands'; DO NOT EDIT

package cli

import (
	"encoding/json"
	"fmt"
	"github.com/imdario/mergo"
	"github.com/sacloud/usacloud/command"
	"github.com/sacloud/usacloud/command/completion"
	"github.com/sacloud/usacloud/command/funcs"
	"github.com/sacloud/usacloud/command/params"
	"github.com/sacloud/usacloud/schema"
	"gopkg.in/urfave/cli.v2"
	"strings"
	"sync"
)

func init() {
	listParam := params.NewListDatabaseParam()
	createParam := params.NewCreateDatabaseParam()
	readParam := params.NewReadDatabaseParam()
	updateParam := params.NewUpdateDatabaseParam()
	deleteParam := params.NewDeleteDatabaseParam()
	bootParam := params.NewBootDatabaseParam()
	shutdownParam := params.NewShutdownDatabaseParam()
	shutdownForceParam := params.NewShutdownForceDatabaseParam()
	resetParam := params.NewResetDatabaseParam()
	waitForBootParam := params.NewWaitForBootDatabaseParam()
	waitForDownParam := params.NewWaitForDownDatabaseParam()
	backupInfoParam := params.NewBackupInfoDatabaseParam()
	backupCreateParam := params.NewBackupCreateDatabaseParam()
	backupRestoreParam := params.NewBackupRestoreDatabaseParam()
	backupLockParam := params.NewBackupLockDatabaseParam()
	backupUnlockParam := params.NewBackupUnlockDatabaseParam()
	backupRemoveParam := params.NewBackupRemoveDatabaseParam()
	monitorCpuParam := params.NewMonitorCpuDatabaseParam()
	monitorMemoryParam := params.NewMonitorMemoryDatabaseParam()
	monitorNicParam := params.NewMonitorNicDatabaseParam()
	monitorSystemDiskParam := params.NewMonitorSystemDiskDatabaseParam()
	monitorBackupDiskParam := params.NewMonitorBackupDiskDatabaseParam()
	monitorSystemDiskSizeParam := params.NewMonitorSystemDiskSizeDatabaseParam()
	monitorBackupDiskSizeParam := params.NewMonitorBackupDiskSizeDatabaseParam()
	logsParam := params.NewLogsDatabaseParam()

	cliCommand := &cli.Command{
		Name:  "database",
		Usage: "A manage commands of Database",
		Subcommands: []*cli.Command{
			{
				Name:    "list",
				Aliases: []string{"ls", "find", "selector"},
				Usage:   "List Database",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "name",
						Usage: "set filter by name(s)",
					},
					&cli.Int64SliceFlag{
						Name:  "id",
						Usage: "set filter by id(s)",
					},
					&cli.StringSliceFlag{
						Name:    "tags",
						Aliases: []string{"selector"},
						Usage:   "set filter by tags(AND)",
					},
					&cli.IntFlag{
						Name:    "from",
						Aliases: []string{"offset"},
						Usage:   "set offset",
					},
					&cli.IntFlag{
						Name:    "max",
						Aliases: []string{"limit"},
						Usage:   "set limit",
					},
					&cli.StringSliceFlag{
						Name:  "sort",
						Usage: "set field(s) for sort",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, listParam)

					// Set option values
					if c.IsSet("name") {
						listParam.Name = c.StringSlice("name")
					}
					if c.IsSet("id") {
						listParam.Id = c.Int64Slice("id")
					}
					if c.IsSet("tags") {
						listParam.Tags = c.StringSlice("tags")
					}
					if c.IsSet("from") {
						listParam.From = c.Int("from")
					}
					if c.IsSet("max") {
						listParam.Max = c.Int("max")
					}
					if c.IsSet("sort") {
						listParam.Sort = c.StringSlice("sort")
					}
					if c.IsSet("param-template") {
						listParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						listParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						listParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						listParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						listParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						listParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						listParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						listParam.FormatFile = c.String("format-file")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.DatabaseListCompleteArgs(ctx, listParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.DatabaseListCompleteArgs(ctx, listParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.DatabaseListCompleteFlags(ctx, listParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.DatabaseListCompleteArgs(ctx, listParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					listParam.ParamTemplate = c.String("param-template")
					listParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(listParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewListDatabaseParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(listParam, p)
					}

					// Set option values
					if c.IsSet("name") {
						listParam.Name = c.StringSlice("name")
					}
					if c.IsSet("id") {
						listParam.Id = c.Int64Slice("id")
					}
					if c.IsSet("tags") {
						listParam.Tags = c.StringSlice("tags")
					}
					if c.IsSet("from") {
						listParam.From = c.Int("from")
					}
					if c.IsSet("max") {
						listParam.Max = c.Int("max")
					}
					if c.IsSet("sort") {
						listParam.Sort = c.StringSlice("sort")
					}
					if c.IsSet("param-template") {
						listParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						listParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						listParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						listParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						listParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						listParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						listParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						listParam.FormatFile = c.String("format-file")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if listParam.GenerateSkeleton {
						listParam.GenerateSkeleton = false
						listParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(listParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := listParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), listParam)

					// Run command with params
					return funcs.DatabaseList(ctx, listParam)

				},
			},
			{
				Name:  "create",
				Usage: "Create Database",
				Flags: []cli.Flag{
					&cli.Int64Flag{
						Name:  "switch-id",
						Usage: "[Required] set connect switch ID",
					},
					&cli.IntFlag{
						Name:  "plan",
						Usage: "[Required] set plan[10/30/90/240]",
						Value: 10,
					},
					&cli.StringFlag{
						Name:    "database",
						Aliases: []string{"db"},
						Usage:   "[Required] set database type",
					},
					&cli.StringFlag{
						Name:  "username",
						Usage: "[Required] set database default user name",
					},
					&cli.StringFlag{
						Name:  "password",
						Usage: "[Required] set database default user password",
					},
					&cli.StringSliceFlag{
						Name:  "source-networks",
						Usage: "set network of allow connection",
					},
					&cli.BoolFlag{
						Name:  "enable-web-ui",
						Usage: "enable web-ui",
					},
					&cli.StringFlag{
						Name:  "backup-time",
						Usage: "set backup start time",
					},
					&cli.IntFlag{
						Name:        "port",
						Usage:       "set database port",
						DefaultText: "PostgreSQL:5432, MariaDB:3306",
					},
					&cli.StringFlag{
						Name:    "ipaddress1",
						Aliases: []string{"ip1", "ipaddress", "ip"},
						Usage:   "[Required] set ipaddress(#1)",
					},
					&cli.IntFlag{
						Name:  "nw-mask-len",
						Usage: "[Required] set network mask length",
					},
					&cli.StringFlag{
						Name:  "default-route",
						Usage: "[Required] set default route",
					},
					&cli.StringFlag{
						Name:  "name",
						Usage: "[Required] set resource display name",
					},
					&cli.StringFlag{
						Name:    "description",
						Aliases: []string{"desc"},
						Usage:   "set resource description",
					},
					&cli.StringSliceFlag{
						Name:  "tags",
						Usage: "set resource tags",
					},
					&cli.Int64Flag{
						Name:  "icon-id",
						Usage: "set Icon ID",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, createParam)

					// Set option values
					if c.IsSet("switch-id") {
						createParam.SwitchId = c.Int64("switch-id")
					}
					if c.IsSet("plan") {
						createParam.Plan = c.Int("plan")
					}
					if c.IsSet("database") {
						createParam.Database = c.String("database")
					}
					if c.IsSet("username") {
						createParam.Username = c.String("username")
					}
					if c.IsSet("password") {
						createParam.Password = c.String("password")
					}
					if c.IsSet("source-networks") {
						createParam.SourceNetworks = c.StringSlice("source-networks")
					}
					if c.IsSet("enable-web-ui") {
						createParam.EnableWebUi = c.Bool("enable-web-ui")
					}
					if c.IsSet("backup-time") {
						createParam.BackupTime = c.String("backup-time")
					}
					if c.IsSet("port") {
						createParam.Port = c.Int("port")
					}
					if c.IsSet("ipaddress1") {
						createParam.Ipaddress1 = c.String("ipaddress1")
					}
					if c.IsSet("nw-mask-len") {
						createParam.NwMaskLen = c.Int("nw-mask-len")
					}
					if c.IsSet("default-route") {
						createParam.DefaultRoute = c.String("default-route")
					}
					if c.IsSet("name") {
						createParam.Name = c.String("name")
					}
					if c.IsSet("description") {
						createParam.Description = c.String("description")
					}
					if c.IsSet("tags") {
						createParam.Tags = c.StringSlice("tags")
					}
					if c.IsSet("icon-id") {
						createParam.IconId = c.Int64("icon-id")
					}
					if c.IsSet("assumeyes") {
						createParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						createParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						createParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						createParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						createParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						createParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						createParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						createParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						createParam.FormatFile = c.String("format-file")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.DatabaseCreateCompleteArgs(ctx, createParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.DatabaseCreateCompleteArgs(ctx, createParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.DatabaseCreateCompleteFlags(ctx, createParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.DatabaseCreateCompleteArgs(ctx, createParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					createParam.ParamTemplate = c.String("param-template")
					createParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(createParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewCreateDatabaseParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(createParam, p)
					}

					// Set option values
					if c.IsSet("switch-id") {
						createParam.SwitchId = c.Int64("switch-id")
					}
					if c.IsSet("plan") {
						createParam.Plan = c.Int("plan")
					}
					if c.IsSet("database") {
						createParam.Database = c.String("database")
					}
					if c.IsSet("username") {
						createParam.Username = c.String("username")
					}
					if c.IsSet("password") {
						createParam.Password = c.String("password")
					}
					if c.IsSet("source-networks") {
						createParam.SourceNetworks = c.StringSlice("source-networks")
					}
					if c.IsSet("enable-web-ui") {
						createParam.EnableWebUi = c.Bool("enable-web-ui")
					}
					if c.IsSet("backup-time") {
						createParam.BackupTime = c.String("backup-time")
					}
					if c.IsSet("port") {
						createParam.Port = c.Int("port")
					}
					if c.IsSet("ipaddress1") {
						createParam.Ipaddress1 = c.String("ipaddress1")
					}
					if c.IsSet("nw-mask-len") {
						createParam.NwMaskLen = c.Int("nw-mask-len")
					}
					if c.IsSet("default-route") {
						createParam.DefaultRoute = c.String("default-route")
					}
					if c.IsSet("name") {
						createParam.Name = c.String("name")
					}
					if c.IsSet("description") {
						createParam.Description = c.String("description")
					}
					if c.IsSet("tags") {
						createParam.Tags = c.StringSlice("tags")
					}
					if c.IsSet("icon-id") {
						createParam.IconId = c.Int64("icon-id")
					}
					if c.IsSet("assumeyes") {
						createParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						createParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						createParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						createParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						createParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						createParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						createParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						createParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						createParam.FormatFile = c.String("format-file")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if createParam.GenerateSkeleton {
						createParam.GenerateSkeleton = false
						createParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(createParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := createParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), createParam)

					// confirm
					if !createParam.Assumeyes && !command.ConfirmContinue("create") {
						return nil
					}

					// Run command with params
					return funcs.DatabaseCreate(ctx, createParam)

				},
			},
			{
				Name:      "read",
				Usage:     "Read Database",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, readParam)

					// Set option values
					if c.IsSet("selector") {
						readParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						readParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						readParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						readParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						readParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						readParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						readParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						readParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						readParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						readParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.DatabaseReadCompleteArgs(ctx, readParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.DatabaseReadCompleteArgs(ctx, readParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.DatabaseReadCompleteFlags(ctx, readParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.DatabaseReadCompleteArgs(ctx, readParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					readParam.ParamTemplate = c.String("param-template")
					readParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(readParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewReadDatabaseParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(readParam, p)
					}

					// Set option values
					if c.IsSet("selector") {
						readParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						readParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						readParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						readParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						readParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						readParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						readParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						readParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						readParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						readParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if readParam.GenerateSkeleton {
						readParam.GenerateSkeleton = false
						readParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(readParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := readParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), readParam)

					apiClient := ctx.GetAPIClient().Database
					ids := []int64{}

					if c.NArg() == 0 {

						if len(readParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Databases {
							if hasTags(&v, readParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", readParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Databases {
										if len(readParam.Selector) == 0 || hasTags(&v, readParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						readParam.SetId(id)
						p := *readParam // copy struct value
						readParam := &p
						go func() {
							err := funcs.DatabaseRead(ctx, readParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "update",
				Usage:     "Update Database",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:  "password",
						Usage: "set database default user password",
					},
					&cli.IntFlag{
						Name:        "port",
						Usage:       "set database port",
						DefaultText: "PostgreSQL:5432, MariaDB:3306",
					},
					&cli.StringSliceFlag{
						Name:  "source-networks",
						Usage: "set network of allow connection",
					},
					&cli.BoolFlag{
						Name:  "enable-web-ui",
						Usage: "enable web-ui",
					},
					&cli.StringFlag{
						Name:  "backup-time",
						Usage: "set backup start time",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "name",
						Usage: "set resource display name",
					},
					&cli.StringFlag{
						Name:    "description",
						Aliases: []string{"desc"},
						Usage:   "set resource description",
					},
					&cli.StringSliceFlag{
						Name:  "tags",
						Usage: "set resource tags",
					},
					&cli.Int64Flag{
						Name:  "icon-id",
						Usage: "set Icon ID",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, updateParam)

					// Set option values
					if c.IsSet("password") {
						updateParam.Password = c.String("password")
					}
					if c.IsSet("port") {
						updateParam.Port = c.Int("port")
					}
					if c.IsSet("source-networks") {
						updateParam.SourceNetworks = c.StringSlice("source-networks")
					}
					if c.IsSet("enable-web-ui") {
						updateParam.EnableWebUi = c.Bool("enable-web-ui")
					}
					if c.IsSet("backup-time") {
						updateParam.BackupTime = c.String("backup-time")
					}
					if c.IsSet("selector") {
						updateParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("name") {
						updateParam.Name = c.String("name")
					}
					if c.IsSet("description") {
						updateParam.Description = c.String("description")
					}
					if c.IsSet("tags") {
						updateParam.Tags = c.StringSlice("tags")
					}
					if c.IsSet("icon-id") {
						updateParam.IconId = c.Int64("icon-id")
					}
					if c.IsSet("assumeyes") {
						updateParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						updateParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						updateParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						updateParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						updateParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						updateParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						updateParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						updateParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						updateParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						updateParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.DatabaseUpdateCompleteArgs(ctx, updateParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.DatabaseUpdateCompleteArgs(ctx, updateParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.DatabaseUpdateCompleteFlags(ctx, updateParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.DatabaseUpdateCompleteArgs(ctx, updateParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					updateParam.ParamTemplate = c.String("param-template")
					updateParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(updateParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewUpdateDatabaseParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(updateParam, p)
					}

					// Set option values
					if c.IsSet("password") {
						updateParam.Password = c.String("password")
					}
					if c.IsSet("port") {
						updateParam.Port = c.Int("port")
					}
					if c.IsSet("source-networks") {
						updateParam.SourceNetworks = c.StringSlice("source-networks")
					}
					if c.IsSet("enable-web-ui") {
						updateParam.EnableWebUi = c.Bool("enable-web-ui")
					}
					if c.IsSet("backup-time") {
						updateParam.BackupTime = c.String("backup-time")
					}
					if c.IsSet("selector") {
						updateParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("name") {
						updateParam.Name = c.String("name")
					}
					if c.IsSet("description") {
						updateParam.Description = c.String("description")
					}
					if c.IsSet("tags") {
						updateParam.Tags = c.StringSlice("tags")
					}
					if c.IsSet("icon-id") {
						updateParam.IconId = c.Int64("icon-id")
					}
					if c.IsSet("assumeyes") {
						updateParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						updateParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						updateParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						updateParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						updateParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						updateParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						updateParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						updateParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						updateParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						updateParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if updateParam.GenerateSkeleton {
						updateParam.GenerateSkeleton = false
						updateParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(updateParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := updateParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), updateParam)

					apiClient := ctx.GetAPIClient().Database
					ids := []int64{}

					if c.NArg() == 0 {

						if len(updateParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Databases {
							if hasTags(&v, updateParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", updateParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Databases {
										if len(updateParam.Selector) == 0 || hasTags(&v, updateParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					// confirm
					if !updateParam.Assumeyes && !command.ConfirmContinue("update", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						updateParam.SetId(id)
						p := *updateParam // copy struct value
						updateParam := &p
						go func() {
							err := funcs.DatabaseUpdate(ctx, updateParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "delete",
				Aliases:   []string{"rm"},
				Usage:     "Delete Database",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.BoolFlag{
						Name:    "force",
						Aliases: []string{"f"},
						Usage:   "forced-shutdown flag if database is running",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, deleteParam)

					// Set option values
					if c.IsSet("selector") {
						deleteParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						deleteParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						deleteParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						deleteParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						deleteParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						deleteParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						deleteParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						deleteParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						deleteParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						deleteParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("force") {
						deleteParam.Force = c.Bool("force")
					}
					if c.IsSet("id") {
						deleteParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.DatabaseDeleteCompleteArgs(ctx, deleteParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.DatabaseDeleteCompleteArgs(ctx, deleteParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.DatabaseDeleteCompleteFlags(ctx, deleteParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.DatabaseDeleteCompleteArgs(ctx, deleteParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					deleteParam.ParamTemplate = c.String("param-template")
					deleteParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(deleteParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewDeleteDatabaseParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(deleteParam, p)
					}

					// Set option values
					if c.IsSet("selector") {
						deleteParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						deleteParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						deleteParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						deleteParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						deleteParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						deleteParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						deleteParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						deleteParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						deleteParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						deleteParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("force") {
						deleteParam.Force = c.Bool("force")
					}
					if c.IsSet("id") {
						deleteParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if deleteParam.GenerateSkeleton {
						deleteParam.GenerateSkeleton = false
						deleteParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(deleteParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := deleteParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), deleteParam)

					apiClient := ctx.GetAPIClient().Database
					ids := []int64{}

					if c.NArg() == 0 {

						if len(deleteParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Databases {
							if hasTags(&v, deleteParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", deleteParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Databases {
										if len(deleteParam.Selector) == 0 || hasTags(&v, deleteParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					// confirm
					if !deleteParam.Assumeyes && !command.ConfirmContinue("delete", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						deleteParam.SetId(id)
						p := *deleteParam // copy struct value
						deleteParam := &p
						go func() {
							err := funcs.DatabaseDelete(ctx, deleteParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "boot",
				Aliases:   []string{"power-on"},
				Usage:     "Boot Database",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, bootParam)

					// Set option values
					if c.IsSet("selector") {
						bootParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						bootParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						bootParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						bootParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						bootParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						bootParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.DatabaseBootCompleteArgs(ctx, bootParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.DatabaseBootCompleteArgs(ctx, bootParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.DatabaseBootCompleteFlags(ctx, bootParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.DatabaseBootCompleteArgs(ctx, bootParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					bootParam.ParamTemplate = c.String("param-template")
					bootParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(bootParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewBootDatabaseParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(bootParam, p)
					}

					// Set option values
					if c.IsSet("selector") {
						bootParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						bootParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						bootParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						bootParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						bootParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						bootParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if bootParam.GenerateSkeleton {
						bootParam.GenerateSkeleton = false
						bootParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(bootParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := bootParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), bootParam)

					apiClient := ctx.GetAPIClient().Database
					ids := []int64{}

					if c.NArg() == 0 {

						if len(bootParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Databases {
							if hasTags(&v, bootParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", bootParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Databases {
										if len(bootParam.Selector) == 0 || hasTags(&v, bootParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					// confirm
					if !bootParam.Assumeyes && !command.ConfirmContinue("boot", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						bootParam.SetId(id)
						p := *bootParam // copy struct value
						bootParam := &p
						go func() {
							err := funcs.DatabaseBoot(ctx, bootParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "shutdown",
				Aliases:   []string{"power-off"},
				Usage:     "Shutdown Database",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, shutdownParam)

					// Set option values
					if c.IsSet("selector") {
						shutdownParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						shutdownParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						shutdownParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						shutdownParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						shutdownParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						shutdownParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.DatabaseShutdownCompleteArgs(ctx, shutdownParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.DatabaseShutdownCompleteArgs(ctx, shutdownParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.DatabaseShutdownCompleteFlags(ctx, shutdownParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.DatabaseShutdownCompleteArgs(ctx, shutdownParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					shutdownParam.ParamTemplate = c.String("param-template")
					shutdownParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(shutdownParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewShutdownDatabaseParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(shutdownParam, p)
					}

					// Set option values
					if c.IsSet("selector") {
						shutdownParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						shutdownParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						shutdownParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						shutdownParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						shutdownParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						shutdownParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if shutdownParam.GenerateSkeleton {
						shutdownParam.GenerateSkeleton = false
						shutdownParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(shutdownParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := shutdownParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), shutdownParam)

					apiClient := ctx.GetAPIClient().Database
					ids := []int64{}

					if c.NArg() == 0 {

						if len(shutdownParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Databases {
							if hasTags(&v, shutdownParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", shutdownParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Databases {
										if len(shutdownParam.Selector) == 0 || hasTags(&v, shutdownParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					// confirm
					if !shutdownParam.Assumeyes && !command.ConfirmContinue("shutdown", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						shutdownParam.SetId(id)
						p := *shutdownParam // copy struct value
						shutdownParam := &p
						go func() {
							err := funcs.DatabaseShutdown(ctx, shutdownParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "shutdown-force",
				Aliases:   []string{"stop"},
				Usage:     "ShutdownForce Database",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, shutdownForceParam)

					// Set option values
					if c.IsSet("selector") {
						shutdownForceParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						shutdownForceParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						shutdownForceParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						shutdownForceParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						shutdownForceParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						shutdownForceParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.DatabaseShutdownForceCompleteArgs(ctx, shutdownForceParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.DatabaseShutdownForceCompleteArgs(ctx, shutdownForceParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.DatabaseShutdownForceCompleteFlags(ctx, shutdownForceParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.DatabaseShutdownForceCompleteArgs(ctx, shutdownForceParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					shutdownForceParam.ParamTemplate = c.String("param-template")
					shutdownForceParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(shutdownForceParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewShutdownForceDatabaseParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(shutdownForceParam, p)
					}

					// Set option values
					if c.IsSet("selector") {
						shutdownForceParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						shutdownForceParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						shutdownForceParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						shutdownForceParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						shutdownForceParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						shutdownForceParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if shutdownForceParam.GenerateSkeleton {
						shutdownForceParam.GenerateSkeleton = false
						shutdownForceParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(shutdownForceParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := shutdownForceParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), shutdownForceParam)

					apiClient := ctx.GetAPIClient().Database
					ids := []int64{}

					if c.NArg() == 0 {

						if len(shutdownForceParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Databases {
							if hasTags(&v, shutdownForceParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", shutdownForceParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Databases {
										if len(shutdownForceParam.Selector) == 0 || hasTags(&v, shutdownForceParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					// confirm
					if !shutdownForceParam.Assumeyes && !command.ConfirmContinue("shutdown-force", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						shutdownForceParam.SetId(id)
						p := *shutdownForceParam // copy struct value
						shutdownForceParam := &p
						go func() {
							err := funcs.DatabaseShutdownForce(ctx, shutdownForceParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "reset",
				Usage:     "Reset Database",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, resetParam)

					// Set option values
					if c.IsSet("selector") {
						resetParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						resetParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						resetParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						resetParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						resetParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						resetParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.DatabaseResetCompleteArgs(ctx, resetParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.DatabaseResetCompleteArgs(ctx, resetParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.DatabaseResetCompleteFlags(ctx, resetParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.DatabaseResetCompleteArgs(ctx, resetParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					resetParam.ParamTemplate = c.String("param-template")
					resetParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(resetParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewResetDatabaseParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(resetParam, p)
					}

					// Set option values
					if c.IsSet("selector") {
						resetParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						resetParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						resetParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						resetParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						resetParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						resetParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if resetParam.GenerateSkeleton {
						resetParam.GenerateSkeleton = false
						resetParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(resetParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := resetParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), resetParam)

					apiClient := ctx.GetAPIClient().Database
					ids := []int64{}

					if c.NArg() == 0 {

						if len(resetParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Databases {
							if hasTags(&v, resetParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", resetParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Databases {
										if len(resetParam.Selector) == 0 || hasTags(&v, resetParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					// confirm
					if !resetParam.Assumeyes && !command.ConfirmContinue("reset", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						resetParam.SetId(id)
						p := *resetParam // copy struct value
						resetParam := &p
						go func() {
							err := funcs.DatabaseReset(ctx, resetParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "wait-for-boot",
				Usage:     "Wait until boot is completed",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, waitForBootParam)

					// Set option values
					if c.IsSet("selector") {
						waitForBootParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						waitForBootParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						waitForBootParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						waitForBootParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						waitForBootParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.DatabaseWaitForBootCompleteArgs(ctx, waitForBootParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.DatabaseWaitForBootCompleteArgs(ctx, waitForBootParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.DatabaseWaitForBootCompleteFlags(ctx, waitForBootParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.DatabaseWaitForBootCompleteArgs(ctx, waitForBootParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					waitForBootParam.ParamTemplate = c.String("param-template")
					waitForBootParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(waitForBootParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewWaitForBootDatabaseParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(waitForBootParam, p)
					}

					// Set option values
					if c.IsSet("selector") {
						waitForBootParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						waitForBootParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						waitForBootParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						waitForBootParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						waitForBootParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if waitForBootParam.GenerateSkeleton {
						waitForBootParam.GenerateSkeleton = false
						waitForBootParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(waitForBootParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := waitForBootParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), waitForBootParam)

					apiClient := ctx.GetAPIClient().Database
					ids := []int64{}

					if c.NArg() == 0 {

						if len(waitForBootParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Databases {
							if hasTags(&v, waitForBootParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", waitForBootParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Databases {
										if len(waitForBootParam.Selector) == 0 || hasTags(&v, waitForBootParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						waitForBootParam.SetId(id)
						p := *waitForBootParam // copy struct value
						waitForBootParam := &p
						go func() {
							err := funcs.DatabaseWaitForBoot(ctx, waitForBootParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "wait-for-down",
				Usage:     "Wait until shutdown is completed",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, waitForDownParam)

					// Set option values
					if c.IsSet("selector") {
						waitForDownParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						waitForDownParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						waitForDownParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						waitForDownParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						waitForDownParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.DatabaseWaitForDownCompleteArgs(ctx, waitForDownParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.DatabaseWaitForDownCompleteArgs(ctx, waitForDownParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.DatabaseWaitForDownCompleteFlags(ctx, waitForDownParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.DatabaseWaitForDownCompleteArgs(ctx, waitForDownParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					waitForDownParam.ParamTemplate = c.String("param-template")
					waitForDownParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(waitForDownParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewWaitForDownDatabaseParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(waitForDownParam, p)
					}

					// Set option values
					if c.IsSet("selector") {
						waitForDownParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						waitForDownParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						waitForDownParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						waitForDownParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						waitForDownParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if waitForDownParam.GenerateSkeleton {
						waitForDownParam.GenerateSkeleton = false
						waitForDownParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(waitForDownParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := waitForDownParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), waitForDownParam)

					apiClient := ctx.GetAPIClient().Database
					ids := []int64{}

					if c.NArg() == 0 {

						if len(waitForDownParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Databases {
							if hasTags(&v, waitForDownParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", waitForDownParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Databases {
										if len(waitForDownParam.Selector) == 0 || hasTags(&v, waitForDownParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						waitForDownParam.SetId(id)
						p := *waitForDownParam // copy struct value
						waitForDownParam := &p
						go func() {
							err := funcs.DatabaseWaitForDown(ctx, waitForDownParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "backup-info",
				Aliases:   []string{"backups", "backup-list"},
				Usage:     "Show information of backup",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, backupInfoParam)

					// Set option values
					if c.IsSet("selector") {
						backupInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						backupInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						backupInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						backupInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						backupInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						backupInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						backupInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						backupInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						backupInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						backupInfoParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.DatabaseBackupInfoCompleteArgs(ctx, backupInfoParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.DatabaseBackupInfoCompleteArgs(ctx, backupInfoParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.DatabaseBackupInfoCompleteFlags(ctx, backupInfoParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.DatabaseBackupInfoCompleteArgs(ctx, backupInfoParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					backupInfoParam.ParamTemplate = c.String("param-template")
					backupInfoParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(backupInfoParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewBackupInfoDatabaseParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(backupInfoParam, p)
					}

					// Set option values
					if c.IsSet("selector") {
						backupInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						backupInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						backupInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						backupInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						backupInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						backupInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						backupInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						backupInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						backupInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						backupInfoParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if backupInfoParam.GenerateSkeleton {
						backupInfoParam.GenerateSkeleton = false
						backupInfoParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(backupInfoParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := backupInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), backupInfoParam)

					apiClient := ctx.GetAPIClient().Database
					ids := []int64{}

					if c.NArg() == 0 {

						if len(backupInfoParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Databases {
							if hasTags(&v, backupInfoParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", backupInfoParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Databases {
										if len(backupInfoParam.Selector) == 0 || hasTags(&v, backupInfoParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						backupInfoParam.SetId(id)
						p := *backupInfoParam // copy struct value
						backupInfoParam := &p
						go func() {
							err := funcs.DatabaseBackupInfo(ctx, backupInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "backup-create",
				Usage:     "Make new database backup",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, backupCreateParam)

					// Set option values
					if c.IsSet("assumeyes") {
						backupCreateParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						backupCreateParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						backupCreateParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						backupCreateParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						backupCreateParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						backupCreateParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						backupCreateParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						backupCreateParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						backupCreateParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						backupCreateParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.DatabaseBackupCreateCompleteArgs(ctx, backupCreateParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.DatabaseBackupCreateCompleteArgs(ctx, backupCreateParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.DatabaseBackupCreateCompleteFlags(ctx, backupCreateParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.DatabaseBackupCreateCompleteArgs(ctx, backupCreateParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					backupCreateParam.ParamTemplate = c.String("param-template")
					backupCreateParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(backupCreateParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewBackupCreateDatabaseParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(backupCreateParam, p)
					}

					// Set option values
					if c.IsSet("assumeyes") {
						backupCreateParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						backupCreateParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						backupCreateParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						backupCreateParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						backupCreateParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						backupCreateParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						backupCreateParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						backupCreateParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						backupCreateParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						backupCreateParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if backupCreateParam.GenerateSkeleton {
						backupCreateParam.GenerateSkeleton = false
						backupCreateParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(backupCreateParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := backupCreateParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), backupCreateParam)

					apiClient := ctx.GetAPIClient().Database
					ids := []int64{}

					if c.NArg() == 0 {

						return fmt.Errorf("ID or Name argument is required")

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Databases {

										ids = append(ids, v.GetID())

									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !backupCreateParam.Assumeyes && !command.ConfirmContinue("backup-create", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						backupCreateParam.SetId(id)
						p := *backupCreateParam // copy struct value
						backupCreateParam := &p
						go func() {
							err := funcs.DatabaseBackupCreate(ctx, backupCreateParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "backup-restore",
				Usage:     "Restore database from backup",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:  "index",
						Usage: "[Required] index of target backup",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, backupRestoreParam)

					// Set option values
					if c.IsSet("index") {
						backupRestoreParam.Index = c.Int("index")
					}
					if c.IsSet("assumeyes") {
						backupRestoreParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						backupRestoreParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						backupRestoreParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						backupRestoreParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						backupRestoreParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						backupRestoreParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						backupRestoreParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						backupRestoreParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						backupRestoreParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						backupRestoreParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.DatabaseBackupRestoreCompleteArgs(ctx, backupRestoreParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.DatabaseBackupRestoreCompleteArgs(ctx, backupRestoreParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.DatabaseBackupRestoreCompleteFlags(ctx, backupRestoreParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.DatabaseBackupRestoreCompleteArgs(ctx, backupRestoreParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					backupRestoreParam.ParamTemplate = c.String("param-template")
					backupRestoreParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(backupRestoreParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewBackupRestoreDatabaseParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(backupRestoreParam, p)
					}

					// Set option values
					if c.IsSet("index") {
						backupRestoreParam.Index = c.Int("index")
					}
					if c.IsSet("assumeyes") {
						backupRestoreParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						backupRestoreParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						backupRestoreParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						backupRestoreParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						backupRestoreParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						backupRestoreParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						backupRestoreParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						backupRestoreParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						backupRestoreParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						backupRestoreParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if backupRestoreParam.GenerateSkeleton {
						backupRestoreParam.GenerateSkeleton = false
						backupRestoreParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(backupRestoreParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := backupRestoreParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), backupRestoreParam)

					apiClient := ctx.GetAPIClient().Database
					ids := []int64{}

					if c.NArg() == 0 {

						return fmt.Errorf("ID or Name argument is required")

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Databases {

										ids = append(ids, v.GetID())

									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !backupRestoreParam.Assumeyes && !command.ConfirmContinue("backup-restore", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						backupRestoreParam.SetId(id)
						p := *backupRestoreParam // copy struct value
						backupRestoreParam := &p
						go func() {
							err := funcs.DatabaseBackupRestore(ctx, backupRestoreParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "backup-lock",
				Usage:     "Lock backup",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:  "index",
						Usage: "[Required] index of target backup",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, backupLockParam)

					// Set option values
					if c.IsSet("index") {
						backupLockParam.Index = c.Int("index")
					}
					if c.IsSet("assumeyes") {
						backupLockParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						backupLockParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						backupLockParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						backupLockParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						backupLockParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						backupLockParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						backupLockParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						backupLockParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						backupLockParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						backupLockParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.DatabaseBackupLockCompleteArgs(ctx, backupLockParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.DatabaseBackupLockCompleteArgs(ctx, backupLockParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.DatabaseBackupLockCompleteFlags(ctx, backupLockParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.DatabaseBackupLockCompleteArgs(ctx, backupLockParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					backupLockParam.ParamTemplate = c.String("param-template")
					backupLockParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(backupLockParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewBackupLockDatabaseParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(backupLockParam, p)
					}

					// Set option values
					if c.IsSet("index") {
						backupLockParam.Index = c.Int("index")
					}
					if c.IsSet("assumeyes") {
						backupLockParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						backupLockParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						backupLockParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						backupLockParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						backupLockParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						backupLockParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						backupLockParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						backupLockParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						backupLockParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						backupLockParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if backupLockParam.GenerateSkeleton {
						backupLockParam.GenerateSkeleton = false
						backupLockParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(backupLockParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := backupLockParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), backupLockParam)

					apiClient := ctx.GetAPIClient().Database
					ids := []int64{}

					if c.NArg() == 0 {

						return fmt.Errorf("ID or Name argument is required")

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Databases {

										ids = append(ids, v.GetID())

									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !backupLockParam.Assumeyes && !command.ConfirmContinue("backup-lock", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						backupLockParam.SetId(id)
						p := *backupLockParam // copy struct value
						backupLockParam := &p
						go func() {
							err := funcs.DatabaseBackupLock(ctx, backupLockParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "backup-unlock",
				Usage:     "Unlock backup",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:  "index",
						Usage: "[Required] index of target backup",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, backupUnlockParam)

					// Set option values
					if c.IsSet("index") {
						backupUnlockParam.Index = c.Int("index")
					}
					if c.IsSet("assumeyes") {
						backupUnlockParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						backupUnlockParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						backupUnlockParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						backupUnlockParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						backupUnlockParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						backupUnlockParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						backupUnlockParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						backupUnlockParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						backupUnlockParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						backupUnlockParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.DatabaseBackupUnlockCompleteArgs(ctx, backupUnlockParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.DatabaseBackupUnlockCompleteArgs(ctx, backupUnlockParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.DatabaseBackupUnlockCompleteFlags(ctx, backupUnlockParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.DatabaseBackupUnlockCompleteArgs(ctx, backupUnlockParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					backupUnlockParam.ParamTemplate = c.String("param-template")
					backupUnlockParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(backupUnlockParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewBackupUnlockDatabaseParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(backupUnlockParam, p)
					}

					// Set option values
					if c.IsSet("index") {
						backupUnlockParam.Index = c.Int("index")
					}
					if c.IsSet("assumeyes") {
						backupUnlockParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						backupUnlockParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						backupUnlockParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						backupUnlockParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						backupUnlockParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						backupUnlockParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						backupUnlockParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						backupUnlockParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						backupUnlockParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						backupUnlockParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if backupUnlockParam.GenerateSkeleton {
						backupUnlockParam.GenerateSkeleton = false
						backupUnlockParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(backupUnlockParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := backupUnlockParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), backupUnlockParam)

					apiClient := ctx.GetAPIClient().Database
					ids := []int64{}

					if c.NArg() == 0 {

						return fmt.Errorf("ID or Name argument is required")

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Databases {

										ids = append(ids, v.GetID())

									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !backupUnlockParam.Assumeyes && !command.ConfirmContinue("backup-unlock", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						backupUnlockParam.SetId(id)
						p := *backupUnlockParam // copy struct value
						backupUnlockParam := &p
						go func() {
							err := funcs.DatabaseBackupUnlock(ctx, backupUnlockParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "backup-remove",
				Usage:     "Remove backup",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:  "index",
						Usage: "[Required] index of target backup",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, backupRemoveParam)

					// Set option values
					if c.IsSet("index") {
						backupRemoveParam.Index = c.Int("index")
					}
					if c.IsSet("assumeyes") {
						backupRemoveParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						backupRemoveParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						backupRemoveParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						backupRemoveParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						backupRemoveParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						backupRemoveParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						backupRemoveParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						backupRemoveParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						backupRemoveParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						backupRemoveParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.DatabaseBackupRemoveCompleteArgs(ctx, backupRemoveParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.DatabaseBackupRemoveCompleteArgs(ctx, backupRemoveParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.DatabaseBackupRemoveCompleteFlags(ctx, backupRemoveParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.DatabaseBackupRemoveCompleteArgs(ctx, backupRemoveParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					backupRemoveParam.ParamTemplate = c.String("param-template")
					backupRemoveParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(backupRemoveParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewBackupRemoveDatabaseParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(backupRemoveParam, p)
					}

					// Set option values
					if c.IsSet("index") {
						backupRemoveParam.Index = c.Int("index")
					}
					if c.IsSet("assumeyes") {
						backupRemoveParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						backupRemoveParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						backupRemoveParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						backupRemoveParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						backupRemoveParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						backupRemoveParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						backupRemoveParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						backupRemoveParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						backupRemoveParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						backupRemoveParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if backupRemoveParam.GenerateSkeleton {
						backupRemoveParam.GenerateSkeleton = false
						backupRemoveParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(backupRemoveParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := backupRemoveParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), backupRemoveParam)

					apiClient := ctx.GetAPIClient().Database
					ids := []int64{}

					if c.NArg() == 0 {

						return fmt.Errorf("ID or Name argument is required")

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Databases {

										ids = append(ids, v.GetID())

									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !backupRemoveParam.Assumeyes && !command.ConfirmContinue("backup-remove", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						backupRemoveParam.SetId(id)
						p := *backupRemoveParam // copy struct value
						backupRemoveParam := &p
						go func() {
							err := funcs.DatabaseBackupRemove(ctx, backupRemoveParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "monitor-cpu",
				Usage:     "Collect CPU monitor values",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:  "start",
						Usage: "set start-time",
					},
					&cli.StringFlag{
						Name:  "end",
						Usage: "set end-time",
					},
					&cli.StringFlag{
						Name:  "key-format",
						Usage: "[Required] set monitoring value key-format",
						Value: "sakuracloud.database.{{.ID}}.cpu",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, monitorCpuParam)

					// Set option values
					if c.IsSet("start") {
						monitorCpuParam.Start = c.String("start")
					}
					if c.IsSet("end") {
						monitorCpuParam.End = c.String("end")
					}
					if c.IsSet("key-format") {
						monitorCpuParam.KeyFormat = c.String("key-format")
					}
					if c.IsSet("selector") {
						monitorCpuParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						monitorCpuParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						monitorCpuParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						monitorCpuParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						monitorCpuParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						monitorCpuParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						monitorCpuParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						monitorCpuParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						monitorCpuParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						monitorCpuParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.DatabaseMonitorCpuCompleteArgs(ctx, monitorCpuParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.DatabaseMonitorCpuCompleteArgs(ctx, monitorCpuParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.DatabaseMonitorCpuCompleteFlags(ctx, monitorCpuParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.DatabaseMonitorCpuCompleteArgs(ctx, monitorCpuParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					monitorCpuParam.ParamTemplate = c.String("param-template")
					monitorCpuParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(monitorCpuParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewMonitorCpuDatabaseParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(monitorCpuParam, p)
					}

					// Set option values
					if c.IsSet("start") {
						monitorCpuParam.Start = c.String("start")
					}
					if c.IsSet("end") {
						monitorCpuParam.End = c.String("end")
					}
					if c.IsSet("key-format") {
						monitorCpuParam.KeyFormat = c.String("key-format")
					}
					if c.IsSet("selector") {
						monitorCpuParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						monitorCpuParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						monitorCpuParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						monitorCpuParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						monitorCpuParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						monitorCpuParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						monitorCpuParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						monitorCpuParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						monitorCpuParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						monitorCpuParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if monitorCpuParam.GenerateSkeleton {
						monitorCpuParam.GenerateSkeleton = false
						monitorCpuParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(monitorCpuParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := monitorCpuParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), monitorCpuParam)

					apiClient := ctx.GetAPIClient().Database
					ids := []int64{}

					if c.NArg() == 0 {

						if len(monitorCpuParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Databases {
							if hasTags(&v, monitorCpuParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", monitorCpuParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Databases {
										if len(monitorCpuParam.Selector) == 0 || hasTags(&v, monitorCpuParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						monitorCpuParam.SetId(id)
						p := *monitorCpuParam // copy struct value
						monitorCpuParam := &p
						go func() {
							err := funcs.DatabaseMonitorCpu(ctx, monitorCpuParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "monitor-memory",
				Usage:     "Collect Disk(s) monitor values",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:  "start",
						Usage: "set start-time",
					},
					&cli.StringFlag{
						Name:  "end",
						Usage: "set end-time",
					},
					&cli.StringFlag{
						Name:  "key-format",
						Usage: "[Required] set monitoring value key-format",
						Value: "sakuracloud.database.{{.ID}}.memory",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, monitorMemoryParam)

					// Set option values
					if c.IsSet("start") {
						monitorMemoryParam.Start = c.String("start")
					}
					if c.IsSet("end") {
						monitorMemoryParam.End = c.String("end")
					}
					if c.IsSet("key-format") {
						monitorMemoryParam.KeyFormat = c.String("key-format")
					}
					if c.IsSet("selector") {
						monitorMemoryParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						monitorMemoryParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						monitorMemoryParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						monitorMemoryParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						monitorMemoryParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						monitorMemoryParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						monitorMemoryParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						monitorMemoryParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						monitorMemoryParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						monitorMemoryParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.DatabaseMonitorMemoryCompleteArgs(ctx, monitorMemoryParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.DatabaseMonitorMemoryCompleteArgs(ctx, monitorMemoryParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.DatabaseMonitorMemoryCompleteFlags(ctx, monitorMemoryParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.DatabaseMonitorMemoryCompleteArgs(ctx, monitorMemoryParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					monitorMemoryParam.ParamTemplate = c.String("param-template")
					monitorMemoryParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(monitorMemoryParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewMonitorMemoryDatabaseParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(monitorMemoryParam, p)
					}

					// Set option values
					if c.IsSet("start") {
						monitorMemoryParam.Start = c.String("start")
					}
					if c.IsSet("end") {
						monitorMemoryParam.End = c.String("end")
					}
					if c.IsSet("key-format") {
						monitorMemoryParam.KeyFormat = c.String("key-format")
					}
					if c.IsSet("selector") {
						monitorMemoryParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						monitorMemoryParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						monitorMemoryParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						monitorMemoryParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						monitorMemoryParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						monitorMemoryParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						monitorMemoryParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						monitorMemoryParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						monitorMemoryParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						monitorMemoryParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if monitorMemoryParam.GenerateSkeleton {
						monitorMemoryParam.GenerateSkeleton = false
						monitorMemoryParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(monitorMemoryParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := monitorMemoryParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), monitorMemoryParam)

					apiClient := ctx.GetAPIClient().Database
					ids := []int64{}

					if c.NArg() == 0 {

						if len(monitorMemoryParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Databases {
							if hasTags(&v, monitorMemoryParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", monitorMemoryParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Databases {
										if len(monitorMemoryParam.Selector) == 0 || hasTags(&v, monitorMemoryParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						monitorMemoryParam.SetId(id)
						p := *monitorMemoryParam // copy struct value
						monitorMemoryParam := &p
						go func() {
							err := funcs.DatabaseMonitorMemory(ctx, monitorMemoryParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "monitor-nic",
				Usage:     "Collect NIC(s) monitor values",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:  "start",
						Usage: "set start-time",
					},
					&cli.StringFlag{
						Name:  "end",
						Usage: "set end-time",
					},
					&cli.StringFlag{
						Name:  "key-format",
						Usage: "[Required] set monitoring value key-format",
						Value: "sakuracloud.database.{{.ID}}.nic",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, monitorNicParam)

					// Set option values
					if c.IsSet("start") {
						monitorNicParam.Start = c.String("start")
					}
					if c.IsSet("end") {
						monitorNicParam.End = c.String("end")
					}
					if c.IsSet("key-format") {
						monitorNicParam.KeyFormat = c.String("key-format")
					}
					if c.IsSet("selector") {
						monitorNicParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						monitorNicParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						monitorNicParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						monitorNicParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						monitorNicParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						monitorNicParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						monitorNicParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						monitorNicParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						monitorNicParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						monitorNicParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.DatabaseMonitorNicCompleteArgs(ctx, monitorNicParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.DatabaseMonitorNicCompleteArgs(ctx, monitorNicParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.DatabaseMonitorNicCompleteFlags(ctx, monitorNicParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.DatabaseMonitorNicCompleteArgs(ctx, monitorNicParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					monitorNicParam.ParamTemplate = c.String("param-template")
					monitorNicParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(monitorNicParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewMonitorNicDatabaseParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(monitorNicParam, p)
					}

					// Set option values
					if c.IsSet("start") {
						monitorNicParam.Start = c.String("start")
					}
					if c.IsSet("end") {
						monitorNicParam.End = c.String("end")
					}
					if c.IsSet("key-format") {
						monitorNicParam.KeyFormat = c.String("key-format")
					}
					if c.IsSet("selector") {
						monitorNicParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						monitorNicParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						monitorNicParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						monitorNicParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						monitorNicParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						monitorNicParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						monitorNicParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						monitorNicParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						monitorNicParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						monitorNicParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if monitorNicParam.GenerateSkeleton {
						monitorNicParam.GenerateSkeleton = false
						monitorNicParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(monitorNicParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := monitorNicParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), monitorNicParam)

					apiClient := ctx.GetAPIClient().Database
					ids := []int64{}

					if c.NArg() == 0 {

						if len(monitorNicParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Databases {
							if hasTags(&v, monitorNicParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", monitorNicParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Databases {
										if len(monitorNicParam.Selector) == 0 || hasTags(&v, monitorNicParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						monitorNicParam.SetId(id)
						p := *monitorNicParam // copy struct value
						monitorNicParam := &p
						go func() {
							err := funcs.DatabaseMonitorNic(ctx, monitorNicParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "monitor-system-disk",
				Usage:     "Collect Disk(s) monitor values",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:  "start",
						Usage: "set start-time",
					},
					&cli.StringFlag{
						Name:  "end",
						Usage: "set end-time",
					},
					&cli.StringFlag{
						Name:  "key-format",
						Usage: "[Required] set monitoring value key-format",
						Value: "sakuracloud.database.{{.ID}}.disk1",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, monitorSystemDiskParam)

					// Set option values
					if c.IsSet("start") {
						monitorSystemDiskParam.Start = c.String("start")
					}
					if c.IsSet("end") {
						monitorSystemDiskParam.End = c.String("end")
					}
					if c.IsSet("key-format") {
						monitorSystemDiskParam.KeyFormat = c.String("key-format")
					}
					if c.IsSet("selector") {
						monitorSystemDiskParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						monitorSystemDiskParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						monitorSystemDiskParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						monitorSystemDiskParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						monitorSystemDiskParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						monitorSystemDiskParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						monitorSystemDiskParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						monitorSystemDiskParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						monitorSystemDiskParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						monitorSystemDiskParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.DatabaseMonitorSystemDiskCompleteArgs(ctx, monitorSystemDiskParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.DatabaseMonitorSystemDiskCompleteArgs(ctx, monitorSystemDiskParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.DatabaseMonitorSystemDiskCompleteFlags(ctx, monitorSystemDiskParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.DatabaseMonitorSystemDiskCompleteArgs(ctx, monitorSystemDiskParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					monitorSystemDiskParam.ParamTemplate = c.String("param-template")
					monitorSystemDiskParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(monitorSystemDiskParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewMonitorSystemDiskDatabaseParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(monitorSystemDiskParam, p)
					}

					// Set option values
					if c.IsSet("start") {
						monitorSystemDiskParam.Start = c.String("start")
					}
					if c.IsSet("end") {
						monitorSystemDiskParam.End = c.String("end")
					}
					if c.IsSet("key-format") {
						monitorSystemDiskParam.KeyFormat = c.String("key-format")
					}
					if c.IsSet("selector") {
						monitorSystemDiskParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						monitorSystemDiskParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						monitorSystemDiskParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						monitorSystemDiskParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						monitorSystemDiskParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						monitorSystemDiskParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						monitorSystemDiskParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						monitorSystemDiskParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						monitorSystemDiskParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						monitorSystemDiskParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if monitorSystemDiskParam.GenerateSkeleton {
						monitorSystemDiskParam.GenerateSkeleton = false
						monitorSystemDiskParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(monitorSystemDiskParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := monitorSystemDiskParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), monitorSystemDiskParam)

					apiClient := ctx.GetAPIClient().Database
					ids := []int64{}

					if c.NArg() == 0 {

						if len(monitorSystemDiskParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Databases {
							if hasTags(&v, monitorSystemDiskParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", monitorSystemDiskParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Databases {
										if len(monitorSystemDiskParam.Selector) == 0 || hasTags(&v, monitorSystemDiskParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						monitorSystemDiskParam.SetId(id)
						p := *monitorSystemDiskParam // copy struct value
						monitorSystemDiskParam := &p
						go func() {
							err := funcs.DatabaseMonitorSystemDisk(ctx, monitorSystemDiskParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "monitor-backup-disk",
				Usage:     "Collect Disk(s) monitor values",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:  "start",
						Usage: "set start-time",
					},
					&cli.StringFlag{
						Name:  "end",
						Usage: "set end-time",
					},
					&cli.StringFlag{
						Name:  "key-format",
						Usage: "[Required] set monitoring value key-format",
						Value: "sakuracloud.database.{{.ID}}.disk2",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, monitorBackupDiskParam)

					// Set option values
					if c.IsSet("start") {
						monitorBackupDiskParam.Start = c.String("start")
					}
					if c.IsSet("end") {
						monitorBackupDiskParam.End = c.String("end")
					}
					if c.IsSet("key-format") {
						monitorBackupDiskParam.KeyFormat = c.String("key-format")
					}
					if c.IsSet("selector") {
						monitorBackupDiskParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						monitorBackupDiskParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						monitorBackupDiskParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						monitorBackupDiskParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						monitorBackupDiskParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						monitorBackupDiskParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						monitorBackupDiskParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						monitorBackupDiskParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						monitorBackupDiskParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						monitorBackupDiskParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.DatabaseMonitorBackupDiskCompleteArgs(ctx, monitorBackupDiskParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.DatabaseMonitorBackupDiskCompleteArgs(ctx, monitorBackupDiskParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.DatabaseMonitorBackupDiskCompleteFlags(ctx, monitorBackupDiskParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.DatabaseMonitorBackupDiskCompleteArgs(ctx, monitorBackupDiskParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					monitorBackupDiskParam.ParamTemplate = c.String("param-template")
					monitorBackupDiskParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(monitorBackupDiskParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewMonitorBackupDiskDatabaseParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(monitorBackupDiskParam, p)
					}

					// Set option values
					if c.IsSet("start") {
						monitorBackupDiskParam.Start = c.String("start")
					}
					if c.IsSet("end") {
						monitorBackupDiskParam.End = c.String("end")
					}
					if c.IsSet("key-format") {
						monitorBackupDiskParam.KeyFormat = c.String("key-format")
					}
					if c.IsSet("selector") {
						monitorBackupDiskParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						monitorBackupDiskParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						monitorBackupDiskParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						monitorBackupDiskParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						monitorBackupDiskParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						monitorBackupDiskParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						monitorBackupDiskParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						monitorBackupDiskParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						monitorBackupDiskParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						monitorBackupDiskParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if monitorBackupDiskParam.GenerateSkeleton {
						monitorBackupDiskParam.GenerateSkeleton = false
						monitorBackupDiskParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(monitorBackupDiskParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := monitorBackupDiskParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), monitorBackupDiskParam)

					apiClient := ctx.GetAPIClient().Database
					ids := []int64{}

					if c.NArg() == 0 {

						if len(monitorBackupDiskParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Databases {
							if hasTags(&v, monitorBackupDiskParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", monitorBackupDiskParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Databases {
										if len(monitorBackupDiskParam.Selector) == 0 || hasTags(&v, monitorBackupDiskParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						monitorBackupDiskParam.SetId(id)
						p := *monitorBackupDiskParam // copy struct value
						monitorBackupDiskParam := &p
						go func() {
							err := funcs.DatabaseMonitorBackupDisk(ctx, monitorBackupDiskParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "monitor-system-disk-size",
				Usage:     "Collect Disk(s) monitor values",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:  "start",
						Usage: "set start-time",
					},
					&cli.StringFlag{
						Name:  "end",
						Usage: "set end-time",
					},
					&cli.StringFlag{
						Name:  "key-format",
						Usage: "[Required] set monitoring value key-format",
						Value: "sakuracloud.database.{{.ID}}.disk1",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, monitorSystemDiskSizeParam)

					// Set option values
					if c.IsSet("start") {
						monitorSystemDiskSizeParam.Start = c.String("start")
					}
					if c.IsSet("end") {
						monitorSystemDiskSizeParam.End = c.String("end")
					}
					if c.IsSet("key-format") {
						monitorSystemDiskSizeParam.KeyFormat = c.String("key-format")
					}
					if c.IsSet("selector") {
						monitorSystemDiskSizeParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						monitorSystemDiskSizeParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						monitorSystemDiskSizeParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						monitorSystemDiskSizeParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						monitorSystemDiskSizeParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						monitorSystemDiskSizeParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						monitorSystemDiskSizeParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						monitorSystemDiskSizeParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						monitorSystemDiskSizeParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						monitorSystemDiskSizeParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.DatabaseMonitorSystemDiskSizeCompleteArgs(ctx, monitorSystemDiskSizeParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.DatabaseMonitorSystemDiskSizeCompleteArgs(ctx, monitorSystemDiskSizeParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.DatabaseMonitorSystemDiskSizeCompleteFlags(ctx, monitorSystemDiskSizeParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.DatabaseMonitorSystemDiskSizeCompleteArgs(ctx, monitorSystemDiskSizeParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					monitorSystemDiskSizeParam.ParamTemplate = c.String("param-template")
					monitorSystemDiskSizeParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(monitorSystemDiskSizeParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewMonitorSystemDiskSizeDatabaseParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(monitorSystemDiskSizeParam, p)
					}

					// Set option values
					if c.IsSet("start") {
						monitorSystemDiskSizeParam.Start = c.String("start")
					}
					if c.IsSet("end") {
						monitorSystemDiskSizeParam.End = c.String("end")
					}
					if c.IsSet("key-format") {
						monitorSystemDiskSizeParam.KeyFormat = c.String("key-format")
					}
					if c.IsSet("selector") {
						monitorSystemDiskSizeParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						monitorSystemDiskSizeParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						monitorSystemDiskSizeParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						monitorSystemDiskSizeParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						monitorSystemDiskSizeParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						monitorSystemDiskSizeParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						monitorSystemDiskSizeParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						monitorSystemDiskSizeParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						monitorSystemDiskSizeParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						monitorSystemDiskSizeParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if monitorSystemDiskSizeParam.GenerateSkeleton {
						monitorSystemDiskSizeParam.GenerateSkeleton = false
						monitorSystemDiskSizeParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(monitorSystemDiskSizeParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := monitorSystemDiskSizeParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), monitorSystemDiskSizeParam)

					apiClient := ctx.GetAPIClient().Database
					ids := []int64{}

					if c.NArg() == 0 {

						if len(monitorSystemDiskSizeParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Databases {
							if hasTags(&v, monitorSystemDiskSizeParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", monitorSystemDiskSizeParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Databases {
										if len(monitorSystemDiskSizeParam.Selector) == 0 || hasTags(&v, monitorSystemDiskSizeParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						monitorSystemDiskSizeParam.SetId(id)
						p := *monitorSystemDiskSizeParam // copy struct value
						monitorSystemDiskSizeParam := &p
						go func() {
							err := funcs.DatabaseMonitorSystemDiskSize(ctx, monitorSystemDiskSizeParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "monitor-backup-disk-size",
				Usage:     "Collect Disk(s) monitor values",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:  "start",
						Usage: "set start-time",
					},
					&cli.StringFlag{
						Name:  "end",
						Usage: "set end-time",
					},
					&cli.StringFlag{
						Name:  "key-format",
						Usage: "[Required] set monitoring value key-format",
						Value: "sakuracloud.database.{{.ID}}.disk2",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, monitorBackupDiskSizeParam)

					// Set option values
					if c.IsSet("start") {
						monitorBackupDiskSizeParam.Start = c.String("start")
					}
					if c.IsSet("end") {
						monitorBackupDiskSizeParam.End = c.String("end")
					}
					if c.IsSet("key-format") {
						monitorBackupDiskSizeParam.KeyFormat = c.String("key-format")
					}
					if c.IsSet("selector") {
						monitorBackupDiskSizeParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						monitorBackupDiskSizeParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						monitorBackupDiskSizeParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						monitorBackupDiskSizeParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						monitorBackupDiskSizeParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						monitorBackupDiskSizeParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						monitorBackupDiskSizeParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						monitorBackupDiskSizeParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						monitorBackupDiskSizeParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						monitorBackupDiskSizeParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.DatabaseMonitorBackupDiskSizeCompleteArgs(ctx, monitorBackupDiskSizeParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.DatabaseMonitorBackupDiskSizeCompleteArgs(ctx, monitorBackupDiskSizeParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.DatabaseMonitorBackupDiskSizeCompleteFlags(ctx, monitorBackupDiskSizeParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.DatabaseMonitorBackupDiskSizeCompleteArgs(ctx, monitorBackupDiskSizeParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					monitorBackupDiskSizeParam.ParamTemplate = c.String("param-template")
					monitorBackupDiskSizeParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(monitorBackupDiskSizeParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewMonitorBackupDiskSizeDatabaseParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(monitorBackupDiskSizeParam, p)
					}

					// Set option values
					if c.IsSet("start") {
						monitorBackupDiskSizeParam.Start = c.String("start")
					}
					if c.IsSet("end") {
						monitorBackupDiskSizeParam.End = c.String("end")
					}
					if c.IsSet("key-format") {
						monitorBackupDiskSizeParam.KeyFormat = c.String("key-format")
					}
					if c.IsSet("selector") {
						monitorBackupDiskSizeParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						monitorBackupDiskSizeParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						monitorBackupDiskSizeParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						monitorBackupDiskSizeParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						monitorBackupDiskSizeParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						monitorBackupDiskSizeParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						monitorBackupDiskSizeParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						monitorBackupDiskSizeParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						monitorBackupDiskSizeParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						monitorBackupDiskSizeParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if monitorBackupDiskSizeParam.GenerateSkeleton {
						monitorBackupDiskSizeParam.GenerateSkeleton = false
						monitorBackupDiskSizeParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(monitorBackupDiskSizeParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := monitorBackupDiskSizeParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), monitorBackupDiskSizeParam)

					apiClient := ctx.GetAPIClient().Database
					ids := []int64{}

					if c.NArg() == 0 {

						if len(monitorBackupDiskSizeParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Databases {
							if hasTags(&v, monitorBackupDiskSizeParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", monitorBackupDiskSizeParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Databases {
										if len(monitorBackupDiskSizeParam.Selector) == 0 || hasTags(&v, monitorBackupDiskSizeParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						monitorBackupDiskSizeParam.SetId(id)
						p := *monitorBackupDiskSizeParam // copy struct value
						monitorBackupDiskSizeParam := &p
						go func() {
							err := funcs.DatabaseMonitorBackupDiskSize(ctx, monitorBackupDiskSizeParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "logs",
				Usage:     "Logs Database",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:    "log-name",
						Aliases: []string{"name"},
						Usage:   "set target logfile name",
						Value:   "all",
					},
					&cli.BoolFlag{
						Name:    "follow",
						Aliases: []string{"f"},
						Usage:   "follow log output",
					},
					&cli.Int64Flag{
						Name:  "refresh-interval",
						Usage: "log refresh interval second",
						Value: 3,
					},
					&cli.BoolFlag{
						Name:  "list-log-names",
						Usage: "show log-name list",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, logsParam)

					// Set option values
					if c.IsSet("log-name") {
						logsParam.LogName = c.String("log-name")
					}
					if c.IsSet("follow") {
						logsParam.Follow = c.Bool("follow")
					}
					if c.IsSet("refresh-interval") {
						logsParam.RefreshInterval = c.Int64("refresh-interval")
					}
					if c.IsSet("list-log-names") {
						logsParam.ListLogNames = c.Bool("list-log-names")
					}
					if c.IsSet("selector") {
						logsParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						logsParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						logsParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						logsParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						logsParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.DatabaseLogsCompleteArgs(ctx, logsParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.DatabaseLogsCompleteArgs(ctx, logsParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.DatabaseLogsCompleteFlags(ctx, logsParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.DatabaseLogsCompleteArgs(ctx, logsParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					logsParam.ParamTemplate = c.String("param-template")
					logsParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(logsParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewLogsDatabaseParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(logsParam, p)
					}

					// Set option values
					if c.IsSet("log-name") {
						logsParam.LogName = c.String("log-name")
					}
					if c.IsSet("follow") {
						logsParam.Follow = c.Bool("follow")
					}
					if c.IsSet("refresh-interval") {
						logsParam.RefreshInterval = c.Int64("refresh-interval")
					}
					if c.IsSet("list-log-names") {
						logsParam.ListLogNames = c.Bool("list-log-names")
					}
					if c.IsSet("selector") {
						logsParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						logsParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						logsParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						logsParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						logsParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if logsParam.GenerateSkeleton {
						logsParam.GenerateSkeleton = false
						logsParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(logsParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := logsParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), logsParam)

					apiClient := ctx.GetAPIClient().Database
					ids := []int64{}

					if c.NArg() == 0 {

						if len(logsParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Databases {
							if hasTags(&v, logsParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", logsParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Databases {
										if len(logsParam.Selector) == 0 || hasTags(&v, logsParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						logsParam.SetId(id)
						p := *logsParam // copy struct value
						logsParam := &p
						go func() {
							err := funcs.DatabaseLogs(ctx, logsParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
		},
	}

	// build Category-Resource mapping
	AppendResourceCategoryMap("database", &schema.Category{
		Key:         "appliance",
		DisplayName: "Appliance",
		Order:       40,
	})

	// build Category-Command mapping

	AppendCommandCategoryMap("database", "backup-create", &schema.Category{
		Key:         "backup",
		DisplayName: "Backup Management",
		Order:       30,
	})
	AppendCommandCategoryMap("database", "backup-info", &schema.Category{
		Key:         "backup",
		DisplayName: "Backup Management",
		Order:       30,
	})
	AppendCommandCategoryMap("database", "backup-lock", &schema.Category{
		Key:         "backup",
		DisplayName: "Backup Management",
		Order:       30,
	})
	AppendCommandCategoryMap("database", "backup-remove", &schema.Category{
		Key:         "backup",
		DisplayName: "Backup Management",
		Order:       30,
	})
	AppendCommandCategoryMap("database", "backup-restore", &schema.Category{
		Key:         "backup",
		DisplayName: "Backup Management",
		Order:       30,
	})
	AppendCommandCategoryMap("database", "backup-unlock", &schema.Category{
		Key:         "backup",
		DisplayName: "Backup Management",
		Order:       30,
	})
	AppendCommandCategoryMap("database", "boot", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})
	AppendCommandCategoryMap("database", "create", &schema.Category{
		Key:         "basics",
		DisplayName: "Basics",
		Order:       10,
	})
	AppendCommandCategoryMap("database", "delete", &schema.Category{
		Key:         "basics",
		DisplayName: "Basics",
		Order:       10,
	})
	AppendCommandCategoryMap("database", "list", &schema.Category{
		Key:         "basics",
		DisplayName: "Basics",
		Order:       10,
	})
	AppendCommandCategoryMap("database", "logs", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitoring",
		Order:       40,
	})
	AppendCommandCategoryMap("database", "monitor-backup-disk", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitoring",
		Order:       40,
	})
	AppendCommandCategoryMap("database", "monitor-backup-disk-size", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitoring",
		Order:       40,
	})
	AppendCommandCategoryMap("database", "monitor-cpu", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitoring",
		Order:       40,
	})
	AppendCommandCategoryMap("database", "monitor-memory", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitoring",
		Order:       40,
	})
	AppendCommandCategoryMap("database", "monitor-nic", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitoring",
		Order:       40,
	})
	AppendCommandCategoryMap("database", "monitor-system-disk", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitoring",
		Order:       40,
	})
	AppendCommandCategoryMap("database", "monitor-system-disk-size", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitoring",
		Order:       40,
	})
	AppendCommandCategoryMap("database", "read", &schema.Category{
		Key:         "basics",
		DisplayName: "Basics",
		Order:       10,
	})
	AppendCommandCategoryMap("database", "reset", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})
	AppendCommandCategoryMap("database", "shutdown", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})
	AppendCommandCategoryMap("database", "shutdown-force", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})
	AppendCommandCategoryMap("database", "update", &schema.Category{
		Key:         "basics",
		DisplayName: "Basics",
		Order:       10,
	})
	AppendCommandCategoryMap("database", "wait-for-boot", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})
	AppendCommandCategoryMap("database", "wait-for-down", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})

	// build Category-Param mapping

	AppendFlagCategoryMap("database", "backup-create", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "backup-create", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "backup-create", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "backup-create", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "backup-create", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "backup-create", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("database", "backup-create", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "backup-create", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "backup-create", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "backup-create", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "backup-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "backup-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "backup-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "backup-info", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "backup-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("database", "backup-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "backup-info", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "backup-info", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "backup-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "backup-info", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("database", "backup-lock", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "backup-lock", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "backup-lock", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "backup-lock", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "backup-lock", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "backup-lock", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("database", "backup-lock", "index", &schema.Category{
		Key:         "backup",
		DisplayName: "Backup options",
		Order:       1,
	})
	AppendFlagCategoryMap("database", "backup-lock", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "backup-lock", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "backup-lock", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "backup-lock", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "backup-remove", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "backup-remove", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "backup-remove", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "backup-remove", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "backup-remove", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "backup-remove", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("database", "backup-remove", "index", &schema.Category{
		Key:         "backup",
		DisplayName: "Backup options",
		Order:       1,
	})
	AppendFlagCategoryMap("database", "backup-remove", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "backup-remove", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "backup-remove", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "backup-remove", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "backup-restore", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "backup-restore", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "backup-restore", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "backup-restore", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "backup-restore", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "backup-restore", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("database", "backup-restore", "index", &schema.Category{
		Key:         "backup",
		DisplayName: "Backup options",
		Order:       1,
	})
	AppendFlagCategoryMap("database", "backup-restore", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "backup-restore", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "backup-restore", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "backup-restore", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "backup-unlock", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "backup-unlock", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "backup-unlock", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "backup-unlock", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "backup-unlock", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "backup-unlock", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("database", "backup-unlock", "index", &schema.Category{
		Key:         "backup",
		DisplayName: "Backup options",
		Order:       1,
	})
	AppendFlagCategoryMap("database", "backup-unlock", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "backup-unlock", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "backup-unlock", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "backup-unlock", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "boot", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "boot", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "boot", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("database", "boot", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "boot", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "boot", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("database", "create", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "create", "backup-time", &schema.Category{
		Key:         "database",
		DisplayName: "Database options",
		Order:       10,
	})
	AppendFlagCategoryMap("database", "create", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "create", "database", &schema.Category{
		Key:         "database",
		DisplayName: "Database options",
		Order:       10,
	})
	AppendFlagCategoryMap("database", "create", "default-route", &schema.Category{
		Key:         "network",
		DisplayName: "Network options",
		Order:       20,
	})
	AppendFlagCategoryMap("database", "create", "description", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("database", "create", "enable-web-ui", &schema.Category{
		Key:         "database",
		DisplayName: "Database options",
		Order:       10,
	})
	AppendFlagCategoryMap("database", "create", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "create", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "create", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "create", "icon-id", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("database", "create", "ipaddress1", &schema.Category{
		Key:         "network",
		DisplayName: "Network options",
		Order:       20,
	})
	AppendFlagCategoryMap("database", "create", "name", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("database", "create", "nw-mask-len", &schema.Category{
		Key:         "network",
		DisplayName: "Network options",
		Order:       20,
	})
	AppendFlagCategoryMap("database", "create", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "create", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "create", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "create", "password", &schema.Category{
		Key:         "database",
		DisplayName: "Database options",
		Order:       10,
	})
	AppendFlagCategoryMap("database", "create", "plan", &schema.Category{
		Key:         "database",
		DisplayName: "Database options",
		Order:       10,
	})
	AppendFlagCategoryMap("database", "create", "port", &schema.Category{
		Key:         "network",
		DisplayName: "Network options",
		Order:       20,
	})
	AppendFlagCategoryMap("database", "create", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "create", "source-networks", &schema.Category{
		Key:         "database",
		DisplayName: "Database options",
		Order:       10,
	})
	AppendFlagCategoryMap("database", "create", "switch-id", &schema.Category{
		Key:         "database",
		DisplayName: "Database options",
		Order:       10,
	})
	AppendFlagCategoryMap("database", "create", "tags", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("database", "create", "username", &schema.Category{
		Key:         "database",
		DisplayName: "Database options",
		Order:       10,
	})
	AppendFlagCategoryMap("database", "delete", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "delete", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "delete", "force", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("database", "delete", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "delete", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "delete", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "delete", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("database", "delete", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "delete", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "delete", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "delete", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "delete", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("database", "list", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "list", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "list", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "list", "from", &schema.Category{
		Key:         "limit-offset",
		DisplayName: "Limit/Offset options",
		Order:       2147483597,
	})
	AppendFlagCategoryMap("database", "list", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "list", "id", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("database", "list", "max", &schema.Category{
		Key:         "limit-offset",
		DisplayName: "Limit/Offset options",
		Order:       2147483597,
	})
	AppendFlagCategoryMap("database", "list", "name", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("database", "list", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "list", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "list", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "list", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "list", "sort", &schema.Category{
		Key:         "sort",
		DisplayName: "Sort options",
		Order:       2147483607,
	})
	AppendFlagCategoryMap("database", "list", "tags", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("database", "logs", "follow", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("database", "logs", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "logs", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("database", "logs", "list-log-names", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("database", "logs", "log-name", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("database", "logs", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "logs", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "logs", "refresh-interval", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("database", "logs", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("database", "monitor-backup-disk", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "monitor-backup-disk", "end", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("database", "monitor-backup-disk", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "monitor-backup-disk", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "monitor-backup-disk", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "monitor-backup-disk", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("database", "monitor-backup-disk", "key-format", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("database", "monitor-backup-disk", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "monitor-backup-disk", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "monitor-backup-disk", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "monitor-backup-disk", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "monitor-backup-disk", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("database", "monitor-backup-disk", "start", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("database", "monitor-backup-disk-size", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "monitor-backup-disk-size", "end", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("database", "monitor-backup-disk-size", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "monitor-backup-disk-size", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "monitor-backup-disk-size", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "monitor-backup-disk-size", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("database", "monitor-backup-disk-size", "key-format", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("database", "monitor-backup-disk-size", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "monitor-backup-disk-size", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "monitor-backup-disk-size", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "monitor-backup-disk-size", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "monitor-backup-disk-size", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("database", "monitor-backup-disk-size", "start", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("database", "monitor-cpu", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "monitor-cpu", "end", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("database", "monitor-cpu", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "monitor-cpu", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "monitor-cpu", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "monitor-cpu", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("database", "monitor-cpu", "key-format", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("database", "monitor-cpu", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "monitor-cpu", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "monitor-cpu", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "monitor-cpu", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "monitor-cpu", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("database", "monitor-cpu", "start", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("database", "monitor-memory", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "monitor-memory", "end", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("database", "monitor-memory", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "monitor-memory", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "monitor-memory", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "monitor-memory", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("database", "monitor-memory", "key-format", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("database", "monitor-memory", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "monitor-memory", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "monitor-memory", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "monitor-memory", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "monitor-memory", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("database", "monitor-memory", "start", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("database", "monitor-nic", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "monitor-nic", "end", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("database", "monitor-nic", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "monitor-nic", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "monitor-nic", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "monitor-nic", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("database", "monitor-nic", "key-format", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("database", "monitor-nic", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "monitor-nic", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "monitor-nic", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "monitor-nic", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "monitor-nic", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("database", "monitor-nic", "start", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("database", "monitor-system-disk", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "monitor-system-disk", "end", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("database", "monitor-system-disk", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "monitor-system-disk", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "monitor-system-disk", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "monitor-system-disk", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("database", "monitor-system-disk", "key-format", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("database", "monitor-system-disk", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "monitor-system-disk", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "monitor-system-disk", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "monitor-system-disk", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "monitor-system-disk", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("database", "monitor-system-disk", "start", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("database", "monitor-system-disk-size", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "monitor-system-disk-size", "end", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("database", "monitor-system-disk-size", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "monitor-system-disk-size", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "monitor-system-disk-size", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "monitor-system-disk-size", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("database", "monitor-system-disk-size", "key-format", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("database", "monitor-system-disk-size", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "monitor-system-disk-size", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "monitor-system-disk-size", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "monitor-system-disk-size", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "monitor-system-disk-size", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("database", "monitor-system-disk-size", "start", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("database", "read", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "read", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "read", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "read", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "read", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("database", "read", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "read", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "read", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "read", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "read", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("database", "reset", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "reset", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "reset", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("database", "reset", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "reset", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "reset", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("database", "shutdown", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "shutdown", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "shutdown", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("database", "shutdown", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "shutdown", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "shutdown", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("database", "shutdown-force", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "shutdown-force", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "shutdown-force", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("database", "shutdown-force", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "shutdown-force", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "shutdown-force", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("database", "update", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "update", "backup-time", &schema.Category{
		Key:         "database",
		DisplayName: "Database options",
		Order:       1,
	})
	AppendFlagCategoryMap("database", "update", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "update", "description", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("database", "update", "enable-web-ui", &schema.Category{
		Key:         "database",
		DisplayName: "Database options",
		Order:       1,
	})
	AppendFlagCategoryMap("database", "update", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "update", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "update", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "update", "icon-id", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("database", "update", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("database", "update", "name", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("database", "update", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "update", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "update", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "update", "password", &schema.Category{
		Key:         "database",
		DisplayName: "Database options",
		Order:       1,
	})
	AppendFlagCategoryMap("database", "update", "port", &schema.Category{
		Key:         "database",
		DisplayName: "Database options",
		Order:       1,
	})
	AppendFlagCategoryMap("database", "update", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("database", "update", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("database", "update", "source-networks", &schema.Category{
		Key:         "database",
		DisplayName: "Database options",
		Order:       1,
	})
	AppendFlagCategoryMap("database", "update", "tags", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("database", "wait-for-boot", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "wait-for-boot", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("database", "wait-for-boot", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "wait-for-boot", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "wait-for-boot", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("database", "wait-for-down", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "wait-for-down", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("database", "wait-for-down", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "wait-for-down", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("database", "wait-for-down", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})

	// append command to GlobalContext
	Commands = append(Commands, cliCommand)
}
