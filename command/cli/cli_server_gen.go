// Code generated by 'github.com/sacloud/usacloud/tools/gen-cli-commands'; DO NOT EDIT

package cli

import (
	"fmt"
	"github.com/sacloud/usacloud/command"
	"github.com/sacloud/usacloud/command/completion"
	"github.com/sacloud/usacloud/command/funcs"
	"github.com/sacloud/usacloud/command/params"
	"github.com/sacloud/usacloud/schema"
	"gopkg.in/urfave/cli.v2"
	"strings"
	"sync"
)

func init() {
	listParam := params.NewListServerParam()
	buildParam := params.NewBuildServerParam()
	readParam := params.NewReadServerParam()
	updateParam := params.NewUpdateServerParam()
	deleteParam := params.NewDeleteServerParam()
	planChangeParam := params.NewPlanChangeServerParam()
	bootParam := params.NewBootServerParam()
	shutdownParam := params.NewShutdownServerParam()
	shutdownForceParam := params.NewShutdownForceServerParam()
	resetParam := params.NewResetServerParam()
	waitForBootParam := params.NewWaitForBootServerParam()
	waitForDownParam := params.NewWaitForDownServerParam()
	sshParam := params.NewSshServerParam()
	sshExecParam := params.NewSshExecServerParam()
	scpParam := params.NewScpServerParam()
	vncParam := params.NewVncServerParam()
	vncInfoParam := params.NewVncInfoServerParam()
	vncSendParam := params.NewVncSendServerParam()
	diskInfoParam := params.NewDiskInfoServerParam()
	diskConnectParam := params.NewDiskConnectServerParam()
	diskDisconnectParam := params.NewDiskDisconnectServerParam()
	interfaceInfoParam := params.NewInterfaceInfoServerParam()
	interfaceAddForInternetParam := params.NewInterfaceAddForInternetServerParam()
	interfaceAddForRouterParam := params.NewInterfaceAddForRouterServerParam()
	interfaceAddForSwitchParam := params.NewInterfaceAddForSwitchServerParam()
	interfaceAddDisconnectedParam := params.NewInterfaceAddDisconnectedServerParam()
	isoInfoParam := params.NewIsoInfoServerParam()
	isoInsertParam := params.NewIsoInsertServerParam()
	isoEjectParam := params.NewIsoEjectServerParam()
	monitorCpuParam := params.NewMonitorCpuServerParam()
	monitorNicParam := params.NewMonitorNicServerParam()
	monitorDiskParam := params.NewMonitorDiskServerParam()

	cliCommand := &cli.Command{
		Name:  "server",
		Usage: "A manage commands of Server",
		Subcommands: []*cli.Command{
			{
				Name:    "list",
				Aliases: []string{"ls", "find"},
				Usage:   "List Server",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "name",
						Usage: "set filter by name(s)",
					},
					&cli.Int64SliceFlag{
						Name:  "id",
						Usage: "set filter by id(s)",
					},
					&cli.StringSliceFlag{
						Name:  "tags",
						Usage: "set filter by tags(AND)",
					},
					&cli.IntFlag{
						Name:        "from",
						Aliases:     []string{"offset"},
						Usage:       "set offset",
						Destination: &listParam.From,
					},
					&cli.IntFlag{
						Name:        "max",
						Aliases:     []string{"limit"},
						Usage:       "set limit",
						Destination: &listParam.Max,
					},
					&cli.StringSliceFlag{
						Name:  "sort",
						Usage: "set field(s) for sort",
					},
					&cli.StringFlag{
						Name:        "output-type",
						Aliases:     []string{"out"},
						Usage:       "Output type [json/csv/tsv]",
						Destination: &listParam.OutputType,
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:        "quiet",
						Aliases:     []string{"q"},
						Usage:       "Only display IDs",
						Destination: &listParam.Quiet,
					},
					&cli.StringFlag{
						Name:        "format",
						Aliases:     []string{"fmt"},
						Usage:       "Output format(see text/template package document for detail)",
						Destination: &listParam.Format,
					},
					&cli.StringFlag{
						Name:        "format-file",
						Usage:       "Output format from file(see text/template package document for detail)",
						Destination: &listParam.FormatFile,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, listParam)

					// Set option values for slice
					listParam.Name = c.StringSlice("name")
					listParam.Id = c.Int64Slice("id")
					listParam.Tags = c.StringSlice("tags")
					listParam.Sort = c.StringSlice("sort")
					listParam.Column = c.StringSlice("column")

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerListCompleteArgs(ctx, listParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerListCompleteArgs(ctx, listParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerListCompleteFlags(ctx, listParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerListCompleteArgs(ctx, listParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Set option values for slice
					listParam.Name = c.StringSlice("name")
					listParam.Id = c.Int64Slice("id")
					listParam.Tags = c.StringSlice("tags")
					listParam.Sort = c.StringSlice("sort")
					listParam.Column = c.StringSlice("column")

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := listParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), listParam)

					// Run command with params
					return funcs.ServerList(ctx, listParam)

				},
			},
			{
				Name:  "build",
				Usage: "Build Server",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:        "core",
						Usage:       "[Required] set CPU core count",
						Value:       1,
						Destination: &buildParam.Core,
					},
					&cli.IntFlag{
						Name:        "memory",
						Usage:       "[Required] set memory size(GB)",
						Value:       1,
						Destination: &buildParam.Memory,
					},
					&cli.StringFlag{
						Name:        "disk-mode",
						Usage:       "[Required] disk create mode[create/connect/diskless]",
						Value:       "create",
						Destination: &buildParam.DiskMode,
					},
					&cli.StringFlag{
						Name:        "os-type",
						Usage:       "set source OS type",
						Destination: &buildParam.OsType,
					},
					&cli.StringFlag{
						Name:        "disk-plan",
						Usage:       "set disk plan('hdd' or 'ssd')",
						Value:       "ssd",
						Destination: &buildParam.DiskPlan,
					},
					&cli.StringFlag{
						Name:        "disk-connection",
						Usage:       "set disk connection('virtio' or 'ide')",
						Value:       "virtio",
						Destination: &buildParam.DiskConnection,
					},
					&cli.IntFlag{
						Name:        "disk-size",
						Usage:       "set disk size(GB)",
						Value:       20,
						Destination: &buildParam.DiskSize,
					},
					&cli.Int64Flag{
						Name:        "source-archive-id",
						Usage:       "set source disk ID",
						Destination: &buildParam.SourceArchiveId,
					},
					&cli.Int64Flag{
						Name:        "source-disk-id",
						Usage:       "set source disk ID",
						Destination: &buildParam.SourceDiskId,
					},
					&cli.Int64SliceFlag{
						Name:  "distant-from",
						Usage: "set distant from disk IDs",
					},
					&cli.Int64Flag{
						Name:        "disk-id",
						Usage:       "set connect disk ID",
						Destination: &buildParam.DiskId,
					},
					&cli.Int64Flag{
						Name:        "iso-image-id",
						Usage:       "set iso-image ID",
						Destination: &buildParam.IsoImageId,
					},
					&cli.StringFlag{
						Name:        "network-mode",
						Usage:       "[Required] network connection mode[shared/switch/disconnect/none]",
						Value:       "shared",
						Destination: &buildParam.NetworkMode,
					},
					&cli.BoolFlag{
						Name:        "use-nic-virtio",
						Usage:       "use virtio on nic",
						Value:       true,
						Destination: &buildParam.UseNicVirtio,
					},
					&cli.Int64Flag{
						Name:        "packet-filter-id",
						Usage:       "set packet filter ID",
						Destination: &buildParam.PacketFilterId,
					},
					&cli.Int64Flag{
						Name:        "switch-id",
						Usage:       "set connect switch ID",
						Destination: &buildParam.SwitchId,
					},
					&cli.StringFlag{
						Name:        "hostname",
						Usage:       "set hostname",
						Destination: &buildParam.Hostname,
					},
					&cli.StringFlag{
						Name:        "password",
						Usage:       "set password",
						Destination: &buildParam.Password,
					},
					&cli.BoolFlag{
						Name:        "disable-password-auth",
						Aliases:     []string{"disable-pw-auth"},
						Usage:       "disable password auth on SSH",
						Destination: &buildParam.DisablePasswordAuth,
					},
					&cli.StringFlag{
						Name:        "ipaddress",
						Aliases:     []string{"ip"},
						Usage:       "set ipaddress",
						Destination: &buildParam.Ipaddress,
					},
					&cli.IntFlag{
						Name:        "nw-masklen",
						Aliases:     []string{"network-masklen"},
						Usage:       "set ipaddress  prefix",
						Value:       24,
						Destination: &buildParam.NwMasklen,
					},
					&cli.StringFlag{
						Name:        "default-route",
						Aliases:     []string{"gateway"},
						Usage:       "set default gateway",
						Destination: &buildParam.DefaultRoute,
					},
					&cli.StringSliceFlag{
						Name:    "startup-scripts",
						Aliases: []string{"notes"},
						Usage:   "set startup script(s)",
					},
					&cli.Int64SliceFlag{
						Name:    "startup-script-ids",
						Aliases: []string{"note-ids"},
						Usage:   "set startup script ID(s)",
					},
					&cli.BoolFlag{
						Name:        "startup-scripts-ephemeral",
						Usage:       "set startup script persist mode",
						Value:       true,
						Destination: &buildParam.StartupScriptsEphemeral,
					},
					&cli.StringFlag{
						Name:        "ssh-key-mode",
						Usage:       "ssh-key mode[none/id/generate/upload]",
						Destination: &buildParam.SshKeyMode,
					},
					&cli.StringFlag{
						Name:        "ssh-key-name",
						Usage:       "set ssh-key name",
						Destination: &buildParam.SshKeyName,
					},
					&cli.Int64SliceFlag{
						Name:  "ssh-key-ids",
						Usage: "set ssh-key ID(s)",
					},
					&cli.StringFlag{
						Name:        "ssh-key-pass-phrase",
						Usage:       "set ssh-key pass phrase",
						Destination: &buildParam.SshKeyPassPhrase,
					},
					&cli.StringFlag{
						Name:        "ssh-key-description",
						Usage:       "set ssh-key description",
						Destination: &buildParam.SshKeyDescription,
					},
					&cli.StringFlag{
						Name:        "ssh-key-private-key-output",
						Usage:       "set ssh-key privatekey output path",
						Destination: &buildParam.SshKeyPrivateKeyOutput,
					},
					&cli.StringSliceFlag{
						Name:  "ssh-key-public-keys",
						Usage: "set ssh-key public key ",
					},
					&cli.StringSliceFlag{
						Name:  "ssh-key-public-key-files",
						Usage: "set ssh-key public key file",
					},
					&cli.BoolFlag{
						Name:        "ssh-key-ephemeral",
						Usage:       "set ssh-key persist mode",
						Value:       true,
						Destination: &buildParam.SshKeyEphemeral,
					},
					&cli.StringFlag{
						Name:        "name",
						Usage:       "[Required] set resource display name",
						Destination: &buildParam.Name,
					},
					&cli.StringFlag{
						Name:        "description",
						Aliases:     []string{"desc"},
						Usage:       "set resource description",
						Destination: &buildParam.Description,
					},
					&cli.StringSliceFlag{
						Name:  "tags",
						Usage: "set resource tags",
					},
					&cli.Int64Flag{
						Name:        "icon-id",
						Usage:       "set Icon ID",
						Destination: &buildParam.IconId,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &buildParam.Assumeyes,
					},
					&cli.StringFlag{
						Name:        "output-type",
						Aliases:     []string{"out"},
						Usage:       "Output type [json/csv/tsv]",
						Destination: &buildParam.OutputType,
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:        "quiet",
						Aliases:     []string{"q"},
						Usage:       "Only display IDs",
						Destination: &buildParam.Quiet,
					},
					&cli.StringFlag{
						Name:        "format",
						Aliases:     []string{"fmt"},
						Usage:       "Output format(see text/template package document for detail)",
						Destination: &buildParam.Format,
					},
					&cli.StringFlag{
						Name:        "format-file",
						Usage:       "Output format from file(see text/template package document for detail)",
						Destination: &buildParam.FormatFile,
					},
					&cli.BoolFlag{
						Name:        "us-keyboard",
						Usage:       "use us-keyboard",
						Destination: &buildParam.UsKeyboard,
					},
					&cli.BoolFlag{
						Name:        "disable-boot-after-create",
						Usage:       "boot after create",
						Value:       false,
						Destination: &buildParam.DisableBootAfterCreate,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, buildParam)

					// Set option values for slice
					buildParam.DistantFrom = c.Int64Slice("distant-from")
					buildParam.StartupScripts = c.StringSlice("startup-scripts")
					buildParam.StartupScriptIds = c.Int64Slice("startup-script-ids")
					buildParam.SshKeyIds = c.Int64Slice("ssh-key-ids")
					buildParam.SshKeyPublicKeys = c.StringSlice("ssh-key-public-keys")
					buildParam.SshKeyPublicKeyFiles = c.StringSlice("ssh-key-public-key-files")
					buildParam.Tags = c.StringSlice("tags")
					buildParam.Column = c.StringSlice("column")

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerBuildCompleteArgs(ctx, buildParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerBuildCompleteArgs(ctx, buildParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerBuildCompleteFlags(ctx, buildParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerBuildCompleteArgs(ctx, buildParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Set option values for slice
					buildParam.DistantFrom = c.Int64Slice("distant-from")
					buildParam.StartupScripts = c.StringSlice("startup-scripts")
					buildParam.StartupScriptIds = c.Int64Slice("startup-script-ids")
					buildParam.SshKeyIds = c.Int64Slice("ssh-key-ids")
					buildParam.SshKeyPublicKeys = c.StringSlice("ssh-key-public-keys")
					buildParam.SshKeyPublicKeyFiles = c.StringSlice("ssh-key-public-key-files")
					buildParam.Tags = c.StringSlice("tags")
					buildParam.Column = c.StringSlice("column")

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := buildParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), buildParam)

					// confirm
					if !buildParam.Assumeyes && !command.ConfirmContinue("build") {
						return nil
					}

					// Run command with params
					return funcs.ServerBuild(ctx, buildParam)

				},
			},
			{
				Name:      "read",
				Usage:     "Read Server",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "output-type",
						Aliases:     []string{"out"},
						Usage:       "Output type [json/csv/tsv]",
						Destination: &readParam.OutputType,
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:        "quiet",
						Aliases:     []string{"q"},
						Usage:       "Only display IDs",
						Destination: &readParam.Quiet,
					},
					&cli.StringFlag{
						Name:        "format",
						Aliases:     []string{"fmt"},
						Usage:       "Output format(see text/template package document for detail)",
						Destination: &readParam.Format,
					},
					&cli.StringFlag{
						Name:        "format-file",
						Usage:       "Output format from file(see text/template package document for detail)",
						Destination: &readParam.FormatFile,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &readParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, readParam)

					// Set option values for slice
					readParam.Column = c.StringSlice("column")

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerReadCompleteArgs(ctx, readParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerReadCompleteArgs(ctx, readParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerReadCompleteFlags(ctx, readParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerReadCompleteArgs(ctx, readParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Set option values for slice
					readParam.Column = c.StringSlice("column")

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := readParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), readParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.Servers {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						readParam.SetId(id)
						p := *readParam // copy struct value
						readParam := &p
						go func() {
							err := funcs.ServerRead(ctx, readParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "update",
				Usage:     "Update Server",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "name",
						Usage:       "set resource display name",
						Destination: &updateParam.Name,
					},
					&cli.StringFlag{
						Name:        "description",
						Aliases:     []string{"desc"},
						Usage:       "set resource description",
						Destination: &updateParam.Description,
					},
					&cli.StringSliceFlag{
						Name:  "tags",
						Usage: "set resource tags",
					},
					&cli.Int64Flag{
						Name:        "icon-id",
						Usage:       "set Icon ID",
						Destination: &updateParam.IconId,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &updateParam.Assumeyes,
					},
					&cli.StringFlag{
						Name:        "output-type",
						Aliases:     []string{"out"},
						Usage:       "Output type [json/csv/tsv]",
						Destination: &updateParam.OutputType,
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:        "quiet",
						Aliases:     []string{"q"},
						Usage:       "Only display IDs",
						Destination: &updateParam.Quiet,
					},
					&cli.StringFlag{
						Name:        "format",
						Aliases:     []string{"fmt"},
						Usage:       "Output format(see text/template package document for detail)",
						Destination: &updateParam.Format,
					},
					&cli.StringFlag{
						Name:        "format-file",
						Usage:       "Output format from file(see text/template package document for detail)",
						Destination: &updateParam.FormatFile,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &updateParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, updateParam)

					// Set option values for slice
					updateParam.Tags = c.StringSlice("tags")
					updateParam.Column = c.StringSlice("column")

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerUpdateCompleteArgs(ctx, updateParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerUpdateCompleteArgs(ctx, updateParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerUpdateCompleteFlags(ctx, updateParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerUpdateCompleteArgs(ctx, updateParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Set option values for slice
					updateParam.Tags = c.StringSlice("tags")
					updateParam.Column = c.StringSlice("column")

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := updateParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), updateParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.Servers {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					// confirm
					if !updateParam.Assumeyes && !command.ConfirmContinue("update", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						updateParam.SetId(id)
						p := *updateParam // copy struct value
						updateParam := &p
						go func() {
							err := funcs.ServerUpdate(ctx, updateParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "delete",
				Aliases:   []string{"rm"},
				Usage:     "Delete Server",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.BoolFlag{
						Name:        "force",
						Aliases:     []string{"f"},
						Usage:       "forced-shutdown flag if server is running",
						Destination: &deleteParam.Force,
					},
					&cli.BoolFlag{
						Name:        "without-disk",
						Usage:       "don't delete connected disks with server",
						Destination: &deleteParam.WithoutDisk,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &deleteParam.Assumeyes,
					},
					&cli.StringFlag{
						Name:        "output-type",
						Aliases:     []string{"out"},
						Usage:       "Output type [json/csv/tsv]",
						Destination: &deleteParam.OutputType,
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:        "quiet",
						Aliases:     []string{"q"},
						Usage:       "Only display IDs",
						Destination: &deleteParam.Quiet,
					},
					&cli.StringFlag{
						Name:        "format",
						Aliases:     []string{"fmt"},
						Usage:       "Output format(see text/template package document for detail)",
						Destination: &deleteParam.Format,
					},
					&cli.StringFlag{
						Name:        "format-file",
						Usage:       "Output format from file(see text/template package document for detail)",
						Destination: &deleteParam.FormatFile,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &deleteParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, deleteParam)

					// Set option values for slice
					deleteParam.Column = c.StringSlice("column")

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerDeleteCompleteArgs(ctx, deleteParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerDeleteCompleteArgs(ctx, deleteParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerDeleteCompleteFlags(ctx, deleteParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerDeleteCompleteArgs(ctx, deleteParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Set option values for slice
					deleteParam.Column = c.StringSlice("column")

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := deleteParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), deleteParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.Servers {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					// confirm
					if !deleteParam.Assumeyes && !command.ConfirmContinue("delete", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						deleteParam.SetId(id)
						p := *deleteParam // copy struct value
						deleteParam := &p
						go func() {
							err := funcs.ServerDelete(ctx, deleteParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "plan-change",
				Usage:     "Change server plan(core/memory)",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:        "core",
						Usage:       "[Required] set CPU core count",
						Destination: &planChangeParam.Core,
					},
					&cli.IntFlag{
						Name:        "memory",
						Usage:       "[Required] set memory size(GB)",
						Destination: &planChangeParam.Memory,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &planChangeParam.Assumeyes,
					},
					&cli.StringFlag{
						Name:        "output-type",
						Aliases:     []string{"out"},
						Usage:       "Output type [json/csv/tsv]",
						Destination: &planChangeParam.OutputType,
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:        "quiet",
						Aliases:     []string{"q"},
						Usage:       "Only display IDs",
						Destination: &planChangeParam.Quiet,
					},
					&cli.StringFlag{
						Name:        "format",
						Aliases:     []string{"fmt"},
						Usage:       "Output format(see text/template package document for detail)",
						Destination: &planChangeParam.Format,
					},
					&cli.StringFlag{
						Name:        "format-file",
						Usage:       "Output format from file(see text/template package document for detail)",
						Destination: &planChangeParam.FormatFile,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &planChangeParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, planChangeParam)

					// Set option values for slice
					planChangeParam.Column = c.StringSlice("column")

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerPlanChangeCompleteArgs(ctx, planChangeParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerPlanChangeCompleteArgs(ctx, planChangeParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerPlanChangeCompleteFlags(ctx, planChangeParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerPlanChangeCompleteArgs(ctx, planChangeParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Set option values for slice
					planChangeParam.Column = c.StringSlice("column")

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := planChangeParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), planChangeParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.Servers {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					// confirm
					if !planChangeParam.Assumeyes && !command.ConfirmContinue("plan-change", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						planChangeParam.SetId(id)
						p := *planChangeParam // copy struct value
						planChangeParam := &p
						go func() {
							err := funcs.ServerPlanChange(ctx, planChangeParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "boot",
				Aliases:   []string{"power-on"},
				Usage:     "Boot Server",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &bootParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &bootParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, bootParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerBootCompleteArgs(ctx, bootParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerBootCompleteArgs(ctx, bootParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerBootCompleteFlags(ctx, bootParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerBootCompleteArgs(ctx, bootParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := bootParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), bootParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.Servers {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					// confirm
					if !bootParam.Assumeyes && !command.ConfirmContinue("boot", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						bootParam.SetId(id)
						p := *bootParam // copy struct value
						bootParam := &p
						go func() {
							err := funcs.ServerBoot(ctx, bootParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "shutdown",
				Aliases:   []string{"power-off"},
				Usage:     "Shutdown Server",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &shutdownParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &shutdownParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, shutdownParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerShutdownCompleteArgs(ctx, shutdownParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerShutdownCompleteArgs(ctx, shutdownParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerShutdownCompleteFlags(ctx, shutdownParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerShutdownCompleteArgs(ctx, shutdownParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := shutdownParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), shutdownParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.Servers {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					// confirm
					if !shutdownParam.Assumeyes && !command.ConfirmContinue("shutdown", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						shutdownParam.SetId(id)
						p := *shutdownParam // copy struct value
						shutdownParam := &p
						go func() {
							err := funcs.ServerShutdown(ctx, shutdownParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "shutdown-force",
				Aliases:   []string{"stop"},
				Usage:     "ShutdownForce Server",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &shutdownForceParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &shutdownForceParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, shutdownForceParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerShutdownForceCompleteArgs(ctx, shutdownForceParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerShutdownForceCompleteArgs(ctx, shutdownForceParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerShutdownForceCompleteFlags(ctx, shutdownForceParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerShutdownForceCompleteArgs(ctx, shutdownForceParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := shutdownForceParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), shutdownForceParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.Servers {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					// confirm
					if !shutdownForceParam.Assumeyes && !command.ConfirmContinue("shutdown-force", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						shutdownForceParam.SetId(id)
						p := *shutdownForceParam // copy struct value
						shutdownForceParam := &p
						go func() {
							err := funcs.ServerShutdownForce(ctx, shutdownForceParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "reset",
				Usage:     "Reset Server",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &resetParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &resetParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, resetParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerResetCompleteArgs(ctx, resetParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerResetCompleteArgs(ctx, resetParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerResetCompleteFlags(ctx, resetParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerResetCompleteArgs(ctx, resetParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := resetParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), resetParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.Servers {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					// confirm
					if !resetParam.Assumeyes && !command.ConfirmContinue("reset", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						resetParam.SetId(id)
						p := *resetParam // copy struct value
						resetParam := &p
						go func() {
							err := funcs.ServerReset(ctx, resetParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "wait-for-boot",
				Usage:     "Wait until boot is completed",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &waitForBootParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, waitForBootParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerWaitForBootCompleteArgs(ctx, waitForBootParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerWaitForBootCompleteArgs(ctx, waitForBootParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerWaitForBootCompleteFlags(ctx, waitForBootParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerWaitForBootCompleteArgs(ctx, waitForBootParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := waitForBootParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), waitForBootParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.Servers {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						waitForBootParam.SetId(id)
						p := *waitForBootParam // copy struct value
						waitForBootParam := &p
						go func() {
							err := funcs.ServerWaitForBoot(ctx, waitForBootParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "wait-for-down",
				Usage:     "Wait until shutdown is completed",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &waitForDownParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, waitForDownParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerWaitForDownCompleteArgs(ctx, waitForDownParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerWaitForDownCompleteArgs(ctx, waitForDownParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerWaitForDownCompleteFlags(ctx, waitForDownParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerWaitForDownCompleteArgs(ctx, waitForDownParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := waitForDownParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), waitForDownParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.Servers {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						waitForDownParam.SetId(id)
						p := *waitForDownParam // copy struct value
						waitForDownParam := &p
						go func() {
							err := funcs.ServerWaitForDown(ctx, waitForDownParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "ssh",
				Usage:     "Connect to server by SSH",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "key",
						Aliases:     []string{"i"},
						Usage:       "private-key file path",
						Destination: &sshParam.Key,
					},
					&cli.StringFlag{
						Name:        "user",
						Aliases:     []string{"l"},
						Usage:       "user name",
						Destination: &sshParam.User,
					},
					&cli.IntFlag{
						Name:        "port",
						Aliases:     []string{"p"},
						Usage:       "[Required] port",
						Value:       22,
						Destination: &sshParam.Port,
					},
					&cli.StringFlag{
						Name:        "password",
						Usage:       "password(or private-key pass phrase)",
						EnvVars:     []string{"SAKURACLOUD_SSH_PASSWORD"},
						Destination: &sshParam.Password,
					},
					&cli.BoolFlag{
						Name:        "quiet",
						Aliases:     []string{"q"},
						Usage:       "disable information messages",
						Destination: &sshParam.Quiet,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &sshParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, sshParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerSshCompleteArgs(ctx, sshParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerSshCompleteArgs(ctx, sshParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerSshCompleteFlags(ctx, sshParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerSshCompleteArgs(ctx, sshParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := sshParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), sshParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.Servers {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						sshParam.SetId(id)
						p := *sshParam // copy struct value
						sshParam := &p
						go func() {
							err := funcs.ServerSsh(ctx, sshParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "ssh-exec",
				Usage:     "Execute command on server connected by SSH",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "key",
						Aliases:     []string{"i"},
						Usage:       "private-key file path",
						Destination: &sshExecParam.Key,
					},
					&cli.StringFlag{
						Name:        "user",
						Aliases:     []string{"l"},
						Usage:       "user name",
						Destination: &sshExecParam.User,
					},
					&cli.IntFlag{
						Name:        "port",
						Aliases:     []string{"p"},
						Usage:       "[Required] port",
						Value:       22,
						Destination: &sshExecParam.Port,
					},
					&cli.StringFlag{
						Name:        "password",
						Usage:       "password(or private-key pass phrase)",
						EnvVars:     []string{"SAKURACLOUD_SSH_PASSWORD"},
						Destination: &sshExecParam.Password,
					},
					&cli.BoolFlag{
						Name:        "quiet",
						Aliases:     []string{"q"},
						Usage:       "disable information messages",
						Destination: &sshExecParam.Quiet,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &sshExecParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, sshExecParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerSshExecCompleteArgs(ctx, sshExecParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerSshExecCompleteArgs(ctx, sshExecParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerSshExecCompleteFlags(ctx, sshExecParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerSshExecCompleteArgs(ctx, sshExecParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := sshExecParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), sshExecParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.Servers {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						sshExecParam.SetId(id)
						p := *sshExecParam // copy struct value
						sshExecParam := &p
						go func() {
							err := funcs.ServerSshExec(ctx, sshExecParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "scp",
				Usage:     "Copy files/directories by SSH",
				ArgsUsage: "[ServerID:]<FROM> [ServerID:]<TO>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "key",
						Aliases:     []string{"i"},
						Usage:       "private-key file path",
						Destination: &scpParam.Key,
					},
					&cli.BoolFlag{
						Name:        "recursive",
						Aliases:     []string{"r"},
						Usage:       "set recursive copy flag",
						Destination: &scpParam.Recursive,
					},
					&cli.StringFlag{
						Name:        "user",
						Aliases:     []string{"l"},
						Usage:       "user name",
						Destination: &scpParam.User,
					},
					&cli.IntFlag{
						Name:        "port",
						Aliases:     []string{"p"},
						Usage:       "[Required] port",
						Value:       22,
						Destination: &scpParam.Port,
					},
					&cli.StringFlag{
						Name:        "password",
						Usage:       "password(or private-key pass phrase)",
						EnvVars:     []string{"SAKURACLOUD_SSH_PASSWORD"},
						Destination: &scpParam.Password,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &scpParam.Assumeyes,
					},
					&cli.BoolFlag{
						Name:        "quiet",
						Aliases:     []string{"q"},
						Usage:       "disable information messages",
						Destination: &scpParam.Quiet,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, scpParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerScpCompleteArgs(ctx, scpParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerScpCompleteArgs(ctx, scpParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerScpCompleteFlags(ctx, scpParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerScpCompleteArgs(ctx, scpParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := scpParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), scpParam)

					// confirm
					if !scpParam.Assumeyes && !command.ConfirmContinue("scp") {
						return nil
					}

					// Run command with params
					return funcs.ServerScp(ctx, scpParam)

				},
			},
			{
				Name:      "vnc",
				Usage:     "Open VNC client using the OS's default application",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.BoolFlag{
						Name:        "wait-for-boot",
						Usage:       "wait until the server starts up",
						Destination: &vncParam.WaitForBoot,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &vncParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &vncParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, vncParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerVncCompleteArgs(ctx, vncParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerVncCompleteArgs(ctx, vncParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerVncCompleteFlags(ctx, vncParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerVncCompleteArgs(ctx, vncParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := vncParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), vncParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.Servers {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					// confirm
					if !vncParam.Assumeyes && !command.ConfirmContinue("open VNC client", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						vncParam.SetId(id)
						p := *vncParam // copy struct value
						vncParam := &p
						go func() {
							err := funcs.ServerVnc(ctx, vncParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "vnc-info",
				Usage:     "Show VNC proxy information",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.BoolFlag{
						Name:        "wait-for-boot",
						Usage:       "wait until the server starts up",
						Destination: &vncInfoParam.WaitForBoot,
					},
					&cli.StringFlag{
						Name:        "output-type",
						Aliases:     []string{"out"},
						Usage:       "Output type [json/csv/tsv]",
						Destination: &vncInfoParam.OutputType,
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:        "quiet",
						Aliases:     []string{"q"},
						Usage:       "Only display IDs",
						Destination: &vncInfoParam.Quiet,
					},
					&cli.StringFlag{
						Name:        "format",
						Aliases:     []string{"fmt"},
						Usage:       "Output format(see text/template package document for detail)",
						Destination: &vncInfoParam.Format,
					},
					&cli.StringFlag{
						Name:        "format-file",
						Usage:       "Output format from file(see text/template package document for detail)",
						Destination: &vncInfoParam.FormatFile,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &vncInfoParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, vncInfoParam)

					// Set option values for slice
					vncInfoParam.Column = c.StringSlice("column")

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerVncInfoCompleteArgs(ctx, vncInfoParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerVncInfoCompleteArgs(ctx, vncInfoParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerVncInfoCompleteFlags(ctx, vncInfoParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerVncInfoCompleteArgs(ctx, vncInfoParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Set option values for slice
					vncInfoParam.Column = c.StringSlice("column")

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := vncInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), vncInfoParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.Servers {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						vncInfoParam.SetId(id)
						p := *vncInfoParam // copy struct value
						vncInfoParam := &p
						go func() {
							err := funcs.ServerVncInfo(ctx, vncInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "vnc-send",
				Usage:     "Send keys over VNC connection",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "command",
						Aliases:     []string{"c"},
						Usage:       "command(compatible with HashiCorp Packer's boot_command)",
						Destination: &vncSendParam.Command,
					},
					&cli.StringFlag{
						Name:        "command-file",
						Aliases:     []string{"f"},
						Usage:       "command file(compatible with HashiCorp Packer's boot_command)",
						Destination: &vncSendParam.CommandFile,
					},
					&cli.BoolFlag{
						Name:        "use-us-keyboard",
						Usage:       "use US Keyboard",
						Destination: &vncSendParam.UseUsKeyboard,
					},
					&cli.BoolFlag{
						Name:        "debug",
						Aliases:     []string{"d"},
						Usage:       "write debug info",
						Destination: &vncSendParam.Debug,
					},
					&cli.BoolFlag{
						Name:        "wait-for-boot",
						Usage:       "wait until the server starts up",
						Destination: &vncSendParam.WaitForBoot,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &vncSendParam.Assumeyes,
					},
					&cli.StringFlag{
						Name:        "output-type",
						Aliases:     []string{"out"},
						Usage:       "Output type [json/csv/tsv]",
						Destination: &vncSendParam.OutputType,
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:        "quiet",
						Aliases:     []string{"q"},
						Usage:       "Only display IDs",
						Destination: &vncSendParam.Quiet,
					},
					&cli.StringFlag{
						Name:        "format",
						Aliases:     []string{"fmt"},
						Usage:       "Output format(see text/template package document for detail)",
						Destination: &vncSendParam.Format,
					},
					&cli.StringFlag{
						Name:        "format-file",
						Usage:       "Output format from file(see text/template package document for detail)",
						Destination: &vncSendParam.FormatFile,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &vncSendParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, vncSendParam)

					// Set option values for slice
					vncSendParam.Column = c.StringSlice("column")

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerVncSendCompleteArgs(ctx, vncSendParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerVncSendCompleteArgs(ctx, vncSendParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerVncSendCompleteFlags(ctx, vncSendParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerVncSendCompleteArgs(ctx, vncSendParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Set option values for slice
					vncSendParam.Column = c.StringSlice("column")

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := vncSendParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), vncSendParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.Servers {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !vncSendParam.Assumeyes && !command.ConfirmContinue("vnc-send", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						vncSendParam.SetId(id)
						p := *vncSendParam // copy struct value
						vncSendParam := &p
						go func() {
							err := funcs.ServerVncSend(ctx, vncSendParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "disk-info",
				Aliases:   []string{"disk-list"},
				Usage:     "Show information of disk(s) connected to server",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "output-type",
						Aliases:     []string{"out"},
						Usage:       "Output type [json/csv/tsv]",
						Destination: &diskInfoParam.OutputType,
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:        "quiet",
						Aliases:     []string{"q"},
						Usage:       "Only display IDs",
						Destination: &diskInfoParam.Quiet,
					},
					&cli.StringFlag{
						Name:        "format",
						Aliases:     []string{"fmt"},
						Usage:       "Output format(see text/template package document for detail)",
						Destination: &diskInfoParam.Format,
					},
					&cli.StringFlag{
						Name:        "format-file",
						Usage:       "Output format from file(see text/template package document for detail)",
						Destination: &diskInfoParam.FormatFile,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &diskInfoParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, diskInfoParam)

					// Set option values for slice
					diskInfoParam.Column = c.StringSlice("column")

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerDiskInfoCompleteArgs(ctx, diskInfoParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerDiskInfoCompleteArgs(ctx, diskInfoParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerDiskInfoCompleteFlags(ctx, diskInfoParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerDiskInfoCompleteArgs(ctx, diskInfoParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Set option values for slice
					diskInfoParam.Column = c.StringSlice("column")

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := diskInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), diskInfoParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.Servers {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						diskInfoParam.SetId(id)
						p := *diskInfoParam // copy struct value
						diskInfoParam := &p
						go func() {
							err := funcs.ServerDiskInfo(ctx, diskInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "disk-connect",
				Usage:     "Connect disk to server",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.Int64Flag{
						Name:        "disk-id",
						Usage:       "[Required] set target disk ID",
						Destination: &diskConnectParam.DiskId,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &diskConnectParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &diskConnectParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, diskConnectParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerDiskConnectCompleteArgs(ctx, diskConnectParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerDiskConnectCompleteArgs(ctx, diskConnectParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerDiskConnectCompleteFlags(ctx, diskConnectParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerDiskConnectCompleteArgs(ctx, diskConnectParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := diskConnectParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), diskConnectParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.Servers {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !diskConnectParam.Assumeyes && !command.ConfirmContinue("disk-connect", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						diskConnectParam.SetId(id)
						p := *diskConnectParam // copy struct value
						diskConnectParam := &p
						go func() {
							err := funcs.ServerDiskConnect(ctx, diskConnectParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "disk-disconnect",
				Usage:     "Disconnect disk from server",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.Int64Flag{
						Name:        "disk-id",
						Usage:       "[Required] set target disk ID",
						Destination: &diskDisconnectParam.DiskId,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &diskDisconnectParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &diskDisconnectParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, diskDisconnectParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerDiskDisconnectCompleteArgs(ctx, diskDisconnectParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerDiskDisconnectCompleteArgs(ctx, diskDisconnectParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerDiskDisconnectCompleteFlags(ctx, diskDisconnectParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerDiskDisconnectCompleteArgs(ctx, diskDisconnectParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := diskDisconnectParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), diskDisconnectParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.Servers {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !diskDisconnectParam.Assumeyes && !command.ConfirmContinue("disk-disconnect", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						diskDisconnectParam.SetId(id)
						p := *diskDisconnectParam // copy struct value
						diskDisconnectParam := &p
						go func() {
							err := funcs.ServerDiskDisconnect(ctx, diskDisconnectParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "interface-info",
				Aliases:   []string{"interface-list"},
				Usage:     "Show information of NIC(s) connected to server",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "output-type",
						Aliases:     []string{"out"},
						Usage:       "Output type [json/csv/tsv]",
						Destination: &interfaceInfoParam.OutputType,
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:        "quiet",
						Aliases:     []string{"q"},
						Usage:       "Only display IDs",
						Destination: &interfaceInfoParam.Quiet,
					},
					&cli.StringFlag{
						Name:        "format",
						Aliases:     []string{"fmt"},
						Usage:       "Output format(see text/template package document for detail)",
						Destination: &interfaceInfoParam.Format,
					},
					&cli.StringFlag{
						Name:        "format-file",
						Usage:       "Output format from file(see text/template package document for detail)",
						Destination: &interfaceInfoParam.FormatFile,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &interfaceInfoParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, interfaceInfoParam)

					// Set option values for slice
					interfaceInfoParam.Column = c.StringSlice("column")

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerInterfaceInfoCompleteArgs(ctx, interfaceInfoParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerInterfaceInfoCompleteArgs(ctx, interfaceInfoParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerInterfaceInfoCompleteFlags(ctx, interfaceInfoParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerInterfaceInfoCompleteArgs(ctx, interfaceInfoParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Set option values for slice
					interfaceInfoParam.Column = c.StringSlice("column")

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := interfaceInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), interfaceInfoParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.Servers {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						interfaceInfoParam.SetId(id)
						p := *interfaceInfoParam // copy struct value
						interfaceInfoParam := &p
						go func() {
							err := funcs.ServerInterfaceInfo(ctx, interfaceInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "interface-add-for-internet",
				Usage:     "Create and connect NIC connected to the internet",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.BoolFlag{
						Name:        "without-disk-edit",
						Usage:       "set skip edit-disk flag. if true, don't call DiskEdit API after interface added",
						Destination: &interfaceAddForInternetParam.WithoutDiskEdit,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &interfaceAddForInternetParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &interfaceAddForInternetParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, interfaceAddForInternetParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerInterfaceAddForInternetCompleteArgs(ctx, interfaceAddForInternetParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerInterfaceAddForInternetCompleteArgs(ctx, interfaceAddForInternetParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerInterfaceAddForInternetCompleteFlags(ctx, interfaceAddForInternetParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerInterfaceAddForInternetCompleteArgs(ctx, interfaceAddForInternetParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := interfaceAddForInternetParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), interfaceAddForInternetParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.Servers {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !interfaceAddForInternetParam.Assumeyes && !command.ConfirmContinue("interface-add-for-internet", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						interfaceAddForInternetParam.SetId(id)
						p := *interfaceAddForInternetParam // copy struct value
						interfaceAddForInternetParam := &p
						go func() {
							err := funcs.ServerInterfaceAddForInternet(ctx, interfaceAddForInternetParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "interface-add-for-router",
				Usage:     "Create and connect NIC connected to the router",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.Int64Flag{
						Name:        "switch-id",
						Usage:       "[Required] set connect switch(connected to router) ID",
						Destination: &interfaceAddForRouterParam.SwitchId,
					},
					&cli.BoolFlag{
						Name:        "without-disk-edit",
						Usage:       "set skip edit-disk flag. if true, don't call DiskEdit API after interface added",
						Destination: &interfaceAddForRouterParam.WithoutDiskEdit,
					},
					&cli.StringFlag{
						Name:        "ipaddress",
						Aliases:     []string{"ip"},
						Usage:       "set ipaddress",
						Destination: &interfaceAddForRouterParam.Ipaddress,
					},
					&cli.StringFlag{
						Name:        "default-route",
						Aliases:     []string{"gateway"},
						Usage:       "set default gateway",
						Destination: &interfaceAddForRouterParam.DefaultRoute,
					},
					&cli.IntFlag{
						Name:        "nw-masklen",
						Aliases:     []string{"network-masklen"},
						Usage:       "set ipaddress  prefix",
						Value:       24,
						Destination: &interfaceAddForRouterParam.NwMasklen,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &interfaceAddForRouterParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &interfaceAddForRouterParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, interfaceAddForRouterParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerInterfaceAddForRouterCompleteArgs(ctx, interfaceAddForRouterParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerInterfaceAddForRouterCompleteArgs(ctx, interfaceAddForRouterParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerInterfaceAddForRouterCompleteFlags(ctx, interfaceAddForRouterParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerInterfaceAddForRouterCompleteArgs(ctx, interfaceAddForRouterParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := interfaceAddForRouterParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), interfaceAddForRouterParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.Servers {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !interfaceAddForRouterParam.Assumeyes && !command.ConfirmContinue("interface-add-for-router", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						interfaceAddForRouterParam.SetId(id)
						p := *interfaceAddForRouterParam // copy struct value
						interfaceAddForRouterParam := &p
						go func() {
							err := funcs.ServerInterfaceAddForRouter(ctx, interfaceAddForRouterParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "interface-add-for-switch",
				Usage:     "Create and connect NIC connected to the switch",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.Int64Flag{
						Name:        "switch-id",
						Usage:       "[Required] set connect switch ID",
						Destination: &interfaceAddForSwitchParam.SwitchId,
					},
					&cli.BoolFlag{
						Name:        "without-disk-edit",
						Usage:       "set skip edit-disk flag. if true, don't call DiskEdit API after interface added",
						Destination: &interfaceAddForSwitchParam.WithoutDiskEdit,
					},
					&cli.StringFlag{
						Name:        "ipaddress",
						Aliases:     []string{"ip"},
						Usage:       "set ipaddress",
						Destination: &interfaceAddForSwitchParam.Ipaddress,
					},
					&cli.StringFlag{
						Name:        "default-route",
						Aliases:     []string{"gateway"},
						Usage:       "set default gateway",
						Destination: &interfaceAddForSwitchParam.DefaultRoute,
					},
					&cli.IntFlag{
						Name:        "nw-masklen",
						Aliases:     []string{"network-masklen"},
						Usage:       "set ipaddress  prefix",
						Value:       24,
						Destination: &interfaceAddForSwitchParam.NwMasklen,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &interfaceAddForSwitchParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &interfaceAddForSwitchParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, interfaceAddForSwitchParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerInterfaceAddForSwitchCompleteArgs(ctx, interfaceAddForSwitchParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerInterfaceAddForSwitchCompleteArgs(ctx, interfaceAddForSwitchParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerInterfaceAddForSwitchCompleteFlags(ctx, interfaceAddForSwitchParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerInterfaceAddForSwitchCompleteArgs(ctx, interfaceAddForSwitchParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := interfaceAddForSwitchParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), interfaceAddForSwitchParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.Servers {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !interfaceAddForSwitchParam.Assumeyes && !command.ConfirmContinue("interface-add-for-switch", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						interfaceAddForSwitchParam.SetId(id)
						p := *interfaceAddForSwitchParam // copy struct value
						interfaceAddForSwitchParam := &p
						go func() {
							err := funcs.ServerInterfaceAddForSwitch(ctx, interfaceAddForSwitchParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "interface-add-disconnected",
				Usage:     "Create and connect a disconnected NIC",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &interfaceAddDisconnectedParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &interfaceAddDisconnectedParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, interfaceAddDisconnectedParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerInterfaceAddDisconnectedCompleteArgs(ctx, interfaceAddDisconnectedParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerInterfaceAddDisconnectedCompleteArgs(ctx, interfaceAddDisconnectedParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerInterfaceAddDisconnectedCompleteFlags(ctx, interfaceAddDisconnectedParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerInterfaceAddDisconnectedCompleteArgs(ctx, interfaceAddDisconnectedParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := interfaceAddDisconnectedParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), interfaceAddDisconnectedParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.Servers {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !interfaceAddDisconnectedParam.Assumeyes && !command.ConfirmContinue("interface-add-disconnected", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						interfaceAddDisconnectedParam.SetId(id)
						p := *interfaceAddDisconnectedParam // copy struct value
						interfaceAddDisconnectedParam := &p
						go func() {
							err := funcs.ServerInterfaceAddDisconnected(ctx, interfaceAddDisconnectedParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "iso-info",
				Usage:     "Show information of ISO-Image inserted to server",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "output-type",
						Aliases:     []string{"out"},
						Usage:       "Output type [json/csv/tsv]",
						Destination: &isoInfoParam.OutputType,
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:        "quiet",
						Aliases:     []string{"q"},
						Usage:       "Only display IDs",
						Destination: &isoInfoParam.Quiet,
					},
					&cli.StringFlag{
						Name:        "format",
						Aliases:     []string{"fmt"},
						Usage:       "Output format(see text/template package document for detail)",
						Destination: &isoInfoParam.Format,
					},
					&cli.StringFlag{
						Name:        "format-file",
						Usage:       "Output format from file(see text/template package document for detail)",
						Destination: &isoInfoParam.FormatFile,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &isoInfoParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, isoInfoParam)

					// Set option values for slice
					isoInfoParam.Column = c.StringSlice("column")

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerIsoInfoCompleteArgs(ctx, isoInfoParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerIsoInfoCompleteArgs(ctx, isoInfoParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerIsoInfoCompleteFlags(ctx, isoInfoParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerIsoInfoCompleteArgs(ctx, isoInfoParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Set option values for slice
					isoInfoParam.Column = c.StringSlice("column")

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := isoInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), isoInfoParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.Servers {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						isoInfoParam.SetId(id)
						p := *isoInfoParam // copy struct value
						isoInfoParam := &p
						go func() {
							err := funcs.ServerIsoInfo(ctx, isoInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "iso-insert",
				Usage:     "Insert ISO-Image to server",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.Int64Flag{
						Name:        "iso-image-id",
						Usage:       "set iso-image ID",
						Destination: &isoInsertParam.IsoImageId,
					},
					&cli.IntFlag{
						Name:        "size",
						Usage:       "set iso size(GB)",
						Value:       5,
						Destination: &isoInsertParam.Size,
					},
					&cli.StringFlag{
						Name:        "iso-file",
						Usage:       "set iso image file",
						Destination: &isoInsertParam.IsoFile,
					},
					&cli.StringFlag{
						Name:        "name",
						Usage:       "set resource display name",
						Destination: &isoInsertParam.Name,
					},
					&cli.StringFlag{
						Name:        "description",
						Aliases:     []string{"desc"},
						Usage:       "set resource description",
						Destination: &isoInsertParam.Description,
					},
					&cli.StringSliceFlag{
						Name:  "tags",
						Usage: "set resource tags",
					},
					&cli.Int64Flag{
						Name:        "icon-id",
						Usage:       "set Icon ID",
						Destination: &isoInsertParam.IconId,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &isoInsertParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &isoInsertParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, isoInsertParam)

					// Set option values for slice
					isoInsertParam.Tags = c.StringSlice("tags")

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerIsoInsertCompleteArgs(ctx, isoInsertParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerIsoInsertCompleteArgs(ctx, isoInsertParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerIsoInsertCompleteFlags(ctx, isoInsertParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerIsoInsertCompleteArgs(ctx, isoInsertParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Set option values for slice
					isoInsertParam.Tags = c.StringSlice("tags")

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := isoInsertParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), isoInsertParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.Servers {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !isoInsertParam.Assumeyes && !command.ConfirmContinue("iso-insert", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						isoInsertParam.SetId(id)
						p := *isoInsertParam // copy struct value
						isoInsertParam := &p
						go func() {
							err := funcs.ServerIsoInsert(ctx, isoInsertParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "iso-eject",
				Usage:     "Eject ISO-Image from server",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &isoEjectParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &isoEjectParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, isoEjectParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerIsoEjectCompleteArgs(ctx, isoEjectParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerIsoEjectCompleteArgs(ctx, isoEjectParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerIsoEjectCompleteFlags(ctx, isoEjectParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerIsoEjectCompleteArgs(ctx, isoEjectParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := isoEjectParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), isoEjectParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.Servers {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !isoEjectParam.Assumeyes && !command.ConfirmContinue("iso-eject", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						isoEjectParam.SetId(id)
						p := *isoEjectParam // copy struct value
						isoEjectParam := &p
						go func() {
							err := funcs.ServerIsoEject(ctx, isoEjectParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "monitor-cpu",
				Usage:     "Collect CPU monitor values",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "start",
						Usage:       "set start-time",
						Destination: &monitorCpuParam.Start,
					},
					&cli.StringFlag{
						Name:        "end",
						Usage:       "set end-time",
						Destination: &monitorCpuParam.End,
					},
					&cli.StringFlag{
						Name:        "key-format",
						Usage:       "[Required] set monitoring value key-format",
						Value:       "sakuracloud.{{.ID}}.cpu",
						Destination: &monitorCpuParam.KeyFormat,
					},
					&cli.StringFlag{
						Name:        "output-type",
						Aliases:     []string{"out"},
						Usage:       "Output type [json/csv/tsv]",
						Destination: &monitorCpuParam.OutputType,
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:        "quiet",
						Aliases:     []string{"q"},
						Usage:       "Only display IDs",
						Destination: &monitorCpuParam.Quiet,
					},
					&cli.StringFlag{
						Name:        "format",
						Aliases:     []string{"fmt"},
						Usage:       "Output format(see text/template package document for detail)",
						Destination: &monitorCpuParam.Format,
					},
					&cli.StringFlag{
						Name:        "format-file",
						Usage:       "Output format from file(see text/template package document for detail)",
						Destination: &monitorCpuParam.FormatFile,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &monitorCpuParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, monitorCpuParam)

					// Set option values for slice
					monitorCpuParam.Column = c.StringSlice("column")

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerMonitorCpuCompleteArgs(ctx, monitorCpuParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerMonitorCpuCompleteArgs(ctx, monitorCpuParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerMonitorCpuCompleteFlags(ctx, monitorCpuParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerMonitorCpuCompleteArgs(ctx, monitorCpuParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Set option values for slice
					monitorCpuParam.Column = c.StringSlice("column")

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := monitorCpuParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), monitorCpuParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.Servers {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						monitorCpuParam.SetId(id)
						p := *monitorCpuParam // copy struct value
						monitorCpuParam := &p
						go func() {
							err := funcs.ServerMonitorCpu(ctx, monitorCpuParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "monitor-nic",
				Usage:     "Collect NIC(s) monitor values",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "start",
						Usage:       "set start-time",
						Destination: &monitorNicParam.Start,
					},
					&cli.StringFlag{
						Name:        "end",
						Usage:       "set end-time",
						Destination: &monitorNicParam.End,
					},
					&cli.Int64SliceFlag{
						Name:  "index",
						Usage: "target index(es)",
					},
					&cli.StringFlag{
						Name:        "key-format",
						Usage:       "[Required] set monitoring value key-format",
						Value:       "sakuracloud.{{.ID}}.nic.{{.Index}}",
						Destination: &monitorNicParam.KeyFormat,
					},
					&cli.StringFlag{
						Name:        "output-type",
						Aliases:     []string{"out"},
						Usage:       "Output type [json/csv/tsv]",
						Destination: &monitorNicParam.OutputType,
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:        "quiet",
						Aliases:     []string{"q"},
						Usage:       "Only display IDs",
						Destination: &monitorNicParam.Quiet,
					},
					&cli.StringFlag{
						Name:        "format",
						Aliases:     []string{"fmt"},
						Usage:       "Output format(see text/template package document for detail)",
						Destination: &monitorNicParam.Format,
					},
					&cli.StringFlag{
						Name:        "format-file",
						Usage:       "Output format from file(see text/template package document for detail)",
						Destination: &monitorNicParam.FormatFile,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &monitorNicParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, monitorNicParam)

					// Set option values for slice
					monitorNicParam.Index = c.Int64Slice("index")
					monitorNicParam.Column = c.StringSlice("column")

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerMonitorNicCompleteArgs(ctx, monitorNicParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerMonitorNicCompleteArgs(ctx, monitorNicParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerMonitorNicCompleteFlags(ctx, monitorNicParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerMonitorNicCompleteArgs(ctx, monitorNicParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Set option values for slice
					monitorNicParam.Index = c.Int64Slice("index")
					monitorNicParam.Column = c.StringSlice("column")

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := monitorNicParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), monitorNicParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.Servers {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						monitorNicParam.SetId(id)
						p := *monitorNicParam // copy struct value
						monitorNicParam := &p
						go func() {
							err := funcs.ServerMonitorNic(ctx, monitorNicParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "monitor-disk",
				Usage:     "Collect Disk(s) monitor values",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "start",
						Usage:       "set start-time",
						Destination: &monitorDiskParam.Start,
					},
					&cli.StringFlag{
						Name:        "end",
						Usage:       "set end-time",
						Destination: &monitorDiskParam.End,
					},
					&cli.Int64SliceFlag{
						Name:  "index",
						Usage: "target index(es)",
					},
					&cli.StringFlag{
						Name:        "key-format",
						Usage:       "[Required] set monitoring value key-format",
						Value:       "sakuracloud.{{.ID}}.disk.{{.Index}}",
						Destination: &monitorDiskParam.KeyFormat,
					},
					&cli.StringFlag{
						Name:        "output-type",
						Aliases:     []string{"out"},
						Usage:       "Output type [json/csv/tsv]",
						Destination: &monitorDiskParam.OutputType,
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:        "quiet",
						Aliases:     []string{"q"},
						Usage:       "Only display IDs",
						Destination: &monitorDiskParam.Quiet,
					},
					&cli.StringFlag{
						Name:        "format",
						Aliases:     []string{"fmt"},
						Usage:       "Output format(see text/template package document for detail)",
						Destination: &monitorDiskParam.Format,
					},
					&cli.StringFlag{
						Name:        "format-file",
						Usage:       "Output format from file(see text/template package document for detail)",
						Destination: &monitorDiskParam.FormatFile,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &monitorDiskParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, monitorDiskParam)

					// Set option values for slice
					monitorDiskParam.Index = c.Int64Slice("index")
					monitorDiskParam.Column = c.StringSlice("column")

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerMonitorDiskCompleteArgs(ctx, monitorDiskParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerMonitorDiskCompleteArgs(ctx, monitorDiskParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerMonitorDiskCompleteFlags(ctx, monitorDiskParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerMonitorDiskCompleteArgs(ctx, monitorDiskParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Set option values for slice
					monitorDiskParam.Index = c.Int64Slice("index")
					monitorDiskParam.Column = c.StringSlice("column")

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := monitorDiskParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), monitorDiskParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.Servers {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						monitorDiskParam.SetId(id)
						p := *monitorDiskParam // copy struct value
						monitorDiskParam := &p
						go func() {
							err := funcs.ServerMonitorDisk(ctx, monitorDiskParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
		},
	}

	// build Category-Resource mapping
	AppendResourceCategoryMap("server", &schema.Category{
		Key:         "computing",
		DisplayName: "Computing",
		Order:       10,
	})

	// build Category-Command mapping

	AppendCommandCategoryMap("server", "boot", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})
	AppendCommandCategoryMap("server", "build", &schema.Category{
		Key:         "basics",
		DisplayName: "Basics",
		Order:       10,
	})
	AppendCommandCategoryMap("server", "delete", &schema.Category{
		Key:         "basics",
		DisplayName: "Basics",
		Order:       10,
	})
	AppendCommandCategoryMap("server", "disk-connect", &schema.Category{
		Key:         "disks",
		DisplayName: "Disk(s) Management",
		Order:       40,
	})
	AppendCommandCategoryMap("server", "disk-disconnect", &schema.Category{
		Key:         "disks",
		DisplayName: "Disk(s) Management",
		Order:       40,
	})
	AppendCommandCategoryMap("server", "disk-info", &schema.Category{
		Key:         "disks",
		DisplayName: "Disk(s) Management",
		Order:       40,
	})
	AppendCommandCategoryMap("server", "interface-add-disconnected", &schema.Category{
		Key:         "network",
		DisplayName: "Network Management",
		Order:       50,
	})
	AppendCommandCategoryMap("server", "interface-add-for-internet", &schema.Category{
		Key:         "network",
		DisplayName: "Network Management",
		Order:       50,
	})
	AppendCommandCategoryMap("server", "interface-add-for-router", &schema.Category{
		Key:         "network",
		DisplayName: "Network Management",
		Order:       50,
	})
	AppendCommandCategoryMap("server", "interface-add-for-switch", &schema.Category{
		Key:         "network",
		DisplayName: "Network Management",
		Order:       50,
	})
	AppendCommandCategoryMap("server", "interface-info", &schema.Category{
		Key:         "network",
		DisplayName: "Network Management",
		Order:       50,
	})
	AppendCommandCategoryMap("server", "iso-eject", &schema.Category{
		Key:         "iso",
		DisplayName: "ISO Image Management",
		Order:       60,
	})
	AppendCommandCategoryMap("server", "iso-info", &schema.Category{
		Key:         "iso",
		DisplayName: "ISO Image Management",
		Order:       60,
	})
	AppendCommandCategoryMap("server", "iso-insert", &schema.Category{
		Key:         "iso",
		DisplayName: "ISO Image Management",
		Order:       60,
	})
	AppendCommandCategoryMap("server", "list", &schema.Category{
		Key:         "basics",
		DisplayName: "Basics",
		Order:       10,
	})
	AppendCommandCategoryMap("server", "monitor-cpu", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitoring",
		Order:       70,
	})
	AppendCommandCategoryMap("server", "monitor-disk", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitoring",
		Order:       70,
	})
	AppendCommandCategoryMap("server", "monitor-nic", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitoring",
		Order:       70,
	})
	AppendCommandCategoryMap("server", "plan-change", &schema.Category{
		Key:         "basics",
		DisplayName: "Basics",
		Order:       10,
	})
	AppendCommandCategoryMap("server", "read", &schema.Category{
		Key:         "basics",
		DisplayName: "Basics",
		Order:       10,
	})
	AppendCommandCategoryMap("server", "reset", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})
	AppendCommandCategoryMap("server", "scp", &schema.Category{
		Key:         "connect",
		DisplayName: "SSH/SCP/VNC",
		Order:       30,
	})
	AppendCommandCategoryMap("server", "shutdown", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})
	AppendCommandCategoryMap("server", "shutdown-force", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})
	AppendCommandCategoryMap("server", "ssh", &schema.Category{
		Key:         "connect",
		DisplayName: "SSH/SCP/VNC",
		Order:       30,
	})
	AppendCommandCategoryMap("server", "ssh-exec", &schema.Category{
		Key:         "connect",
		DisplayName: "SSH/SCP/VNC",
		Order:       30,
	})
	AppendCommandCategoryMap("server", "update", &schema.Category{
		Key:         "basics",
		DisplayName: "Basics",
		Order:       10,
	})
	AppendCommandCategoryMap("server", "vnc", &schema.Category{
		Key:         "connect",
		DisplayName: "SSH/SCP/VNC",
		Order:       30,
	})
	AppendCommandCategoryMap("server", "vnc-info", &schema.Category{
		Key:         "connect",
		DisplayName: "SSH/SCP/VNC",
		Order:       30,
	})
	AppendCommandCategoryMap("server", "vnc-send", &schema.Category{
		Key:         "connect",
		DisplayName: "SSH/SCP/VNC",
		Order:       30,
	})
	AppendCommandCategoryMap("server", "wait-for-boot", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})
	AppendCommandCategoryMap("server", "wait-for-down", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})

	// build Category-Param mapping

	AppendFlagCategoryMap("server", "boot", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "boot", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "build", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "build", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "build", "core", &schema.Category{
		Key:         "server-plan",
		DisplayName: "For server-plan options",
		Order:       10,
	})
	AppendFlagCategoryMap("server", "build", "default-route", &schema.Category{
		Key:         "edit-disk-network",
		DisplayName: "For edit-disk(network settings) options",
		Order:       41,
	})
	AppendFlagCategoryMap("server", "build", "description", &schema.Category{
		Key:         "server-info",
		DisplayName: "For server-info options",
		Order:       50,
	})
	AppendFlagCategoryMap("server", "build", "disable-boot-after-create", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "build", "disable-password-auth", &schema.Category{
		Key:         "edit-disk",
		DisplayName: "For edit-disk options",
		Order:       40,
	})
	AppendFlagCategoryMap("server", "build", "disk-connection", &schema.Category{
		Key:         "disk",
		DisplayName: "For disk options",
		Order:       20,
	})
	AppendFlagCategoryMap("server", "build", "disk-id", &schema.Category{
		Key:         "disk",
		DisplayName: "For disk options",
		Order:       20,
	})
	AppendFlagCategoryMap("server", "build", "disk-mode", &schema.Category{
		Key:         "disk",
		DisplayName: "For disk options",
		Order:       20,
	})
	AppendFlagCategoryMap("server", "build", "disk-plan", &schema.Category{
		Key:         "disk",
		DisplayName: "For disk options",
		Order:       20,
	})
	AppendFlagCategoryMap("server", "build", "disk-size", &schema.Category{
		Key:         "disk",
		DisplayName: "For disk options",
		Order:       20,
	})
	AppendFlagCategoryMap("server", "build", "distant-from", &schema.Category{
		Key:         "disk",
		DisplayName: "For disk options",
		Order:       20,
	})
	AppendFlagCategoryMap("server", "build", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "build", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "build", "hostname", &schema.Category{
		Key:         "edit-disk",
		DisplayName: "For edit-disk options",
		Order:       40,
	})
	AppendFlagCategoryMap("server", "build", "icon-id", &schema.Category{
		Key:         "server-info",
		DisplayName: "For server-info options",
		Order:       50,
	})
	AppendFlagCategoryMap("server", "build", "ipaddress", &schema.Category{
		Key:         "edit-disk-network",
		DisplayName: "For edit-disk(network settings) options",
		Order:       41,
	})
	AppendFlagCategoryMap("server", "build", "iso-image-id", &schema.Category{
		Key:         "iso-image",
		DisplayName: "For ISO image options",
		Order:       25,
	})
	AppendFlagCategoryMap("server", "build", "memory", &schema.Category{
		Key:         "server-plan",
		DisplayName: "For server-plan options",
		Order:       10,
	})
	AppendFlagCategoryMap("server", "build", "name", &schema.Category{
		Key:         "server-info",
		DisplayName: "For server-info options",
		Order:       50,
	})
	AppendFlagCategoryMap("server", "build", "network-mode", &schema.Category{
		Key:         "network",
		DisplayName: "For network options",
		Order:       30,
	})
	AppendFlagCategoryMap("server", "build", "nw-masklen", &schema.Category{
		Key:         "edit-disk-network",
		DisplayName: "For edit-disk(network settings) options",
		Order:       41,
	})
	AppendFlagCategoryMap("server", "build", "os-type", &schema.Category{
		Key:         "disk",
		DisplayName: "For disk options",
		Order:       20,
	})
	AppendFlagCategoryMap("server", "build", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "build", "packet-filter-id", &schema.Category{
		Key:         "network",
		DisplayName: "For network options",
		Order:       30,
	})
	AppendFlagCategoryMap("server", "build", "password", &schema.Category{
		Key:         "edit-disk",
		DisplayName: "For edit-disk options",
		Order:       40,
	})
	AppendFlagCategoryMap("server", "build", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "build", "source-archive-id", &schema.Category{
		Key:         "disk",
		DisplayName: "For disk options",
		Order:       20,
	})
	AppendFlagCategoryMap("server", "build", "source-disk-id", &schema.Category{
		Key:         "disk",
		DisplayName: "For disk options",
		Order:       20,
	})
	AppendFlagCategoryMap("server", "build", "ssh-key-description", &schema.Category{
		Key:         "edit-disk-ssh-key",
		DisplayName: "For edit-disk(ssh-key) options",
		Order:       43,
	})
	AppendFlagCategoryMap("server", "build", "ssh-key-ephemeral", &schema.Category{
		Key:         "edit-disk-ssh-key",
		DisplayName: "For edit-disk(ssh-key) options",
		Order:       43,
	})
	AppendFlagCategoryMap("server", "build", "ssh-key-ids", &schema.Category{
		Key:         "edit-disk-ssh-key",
		DisplayName: "For edit-disk(ssh-key) options",
		Order:       43,
	})
	AppendFlagCategoryMap("server", "build", "ssh-key-mode", &schema.Category{
		Key:         "edit-disk-ssh-key",
		DisplayName: "For edit-disk(ssh-key) options",
		Order:       43,
	})
	AppendFlagCategoryMap("server", "build", "ssh-key-name", &schema.Category{
		Key:         "edit-disk-ssh-key",
		DisplayName: "For edit-disk(ssh-key) options",
		Order:       43,
	})
	AppendFlagCategoryMap("server", "build", "ssh-key-pass-phrase", &schema.Category{
		Key:         "edit-disk-ssh-key",
		DisplayName: "For edit-disk(ssh-key) options",
		Order:       43,
	})
	AppendFlagCategoryMap("server", "build", "ssh-key-private-key-output", &schema.Category{
		Key:         "edit-disk-ssh-key",
		DisplayName: "For edit-disk(ssh-key) options",
		Order:       43,
	})
	AppendFlagCategoryMap("server", "build", "ssh-key-public-key-files", &schema.Category{
		Key:         "edit-disk-ssh-key",
		DisplayName: "For edit-disk(ssh-key) options",
		Order:       43,
	})
	AppendFlagCategoryMap("server", "build", "ssh-key-public-keys", &schema.Category{
		Key:         "edit-disk-ssh-key",
		DisplayName: "For edit-disk(ssh-key) options",
		Order:       43,
	})
	AppendFlagCategoryMap("server", "build", "startup-script-ids", &schema.Category{
		Key:         "edit-disk-startup-script",
		DisplayName: "For edit-disk(startup-script) options",
		Order:       42,
	})
	AppendFlagCategoryMap("server", "build", "startup-scripts", &schema.Category{
		Key:         "edit-disk-startup-script",
		DisplayName: "For edit-disk(startup-script) options",
		Order:       42,
	})
	AppendFlagCategoryMap("server", "build", "startup-scripts-ephemeral", &schema.Category{
		Key:         "edit-disk-startup-script",
		DisplayName: "For edit-disk(startup-script) options",
		Order:       42,
	})
	AppendFlagCategoryMap("server", "build", "switch-id", &schema.Category{
		Key:         "network",
		DisplayName: "For network options",
		Order:       30,
	})
	AppendFlagCategoryMap("server", "build", "tags", &schema.Category{
		Key:         "server-info",
		DisplayName: "For server-info options",
		Order:       50,
	})
	AppendFlagCategoryMap("server", "build", "us-keyboard", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "build", "use-nic-virtio", &schema.Category{
		Key:         "network",
		DisplayName: "For network options",
		Order:       30,
	})
	AppendFlagCategoryMap("server", "delete", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "delete", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "delete", "force", &schema.Category{
		Key:         "operation",
		DisplayName: "Operation options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "delete", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "delete", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "delete", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "delete", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "delete", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "delete", "without-disk", &schema.Category{
		Key:         "operation",
		DisplayName: "Operation options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "disk-connect", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "disk-connect", "disk-id", &schema.Category{
		Key:         "disk",
		DisplayName: "Disk options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "disk-connect", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "disk-disconnect", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "disk-disconnect", "disk-id", &schema.Category{
		Key:         "disk",
		DisplayName: "Disk options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "disk-disconnect", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "disk-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "disk-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "disk-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "disk-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "disk-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "disk-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "interface-add-disconnected", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-disconnected", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "interface-add-for-internet", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-for-internet", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "interface-add-for-internet", "without-disk-edit", &schema.Category{
		Key:         "disk-edit",
		DisplayName: "Disk-Edit options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "interface-add-for-router", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-for-router", "default-route", &schema.Category{
		Key:         "disk-edit",
		DisplayName: "Disk-Edit options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "interface-add-for-router", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "interface-add-for-router", "ipaddress", &schema.Category{
		Key:         "disk-edit",
		DisplayName: "Disk-Edit options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "interface-add-for-router", "nw-masklen", &schema.Category{
		Key:         "disk-edit",
		DisplayName: "Disk-Edit options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "interface-add-for-router", "switch-id", &schema.Category{
		Key:         "connect",
		DisplayName: "Connect options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "interface-add-for-router", "without-disk-edit", &schema.Category{
		Key:         "disk-edit",
		DisplayName: "Disk-Edit options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "interface-add-for-switch", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-for-switch", "default-route", &schema.Category{
		Key:         "disk-edit",
		DisplayName: "Disk-Edit options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "interface-add-for-switch", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "interface-add-for-switch", "ipaddress", &schema.Category{
		Key:         "disk-edit",
		DisplayName: "Disk-Edit options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "interface-add-for-switch", "nw-masklen", &schema.Category{
		Key:         "disk-edit",
		DisplayName: "Disk-Edit options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "interface-add-for-switch", "switch-id", &schema.Category{
		Key:         "connect",
		DisplayName: "Connect options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "interface-add-for-switch", "without-disk-edit", &schema.Category{
		Key:         "disk-edit",
		DisplayName: "Disk-Edit options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "interface-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "interface-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "interface-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "interface-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "interface-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "interface-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "iso-eject", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "iso-eject", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "iso-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "iso-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "iso-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "iso-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "iso-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "iso-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "iso-insert", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "iso-insert", "description", &schema.Category{
		Key:         "ISO-upload",
		DisplayName: "ISO-Upload options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "iso-insert", "icon-id", &schema.Category{
		Key:         "ISO-upload",
		DisplayName: "ISO-Upload options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "iso-insert", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "iso-insert", "iso-file", &schema.Category{
		Key:         "ISO-upload",
		DisplayName: "ISO-Upload options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "iso-insert", "iso-image-id", &schema.Category{
		Key:         "ISO-insert",
		DisplayName: "ISO-Insert options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "iso-insert", "name", &schema.Category{
		Key:         "ISO-upload",
		DisplayName: "ISO-Upload options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "iso-insert", "size", &schema.Category{
		Key:         "ISO-upload",
		DisplayName: "ISO-Upload options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "iso-insert", "tags", &schema.Category{
		Key:         "ISO-upload",
		DisplayName: "ISO-Upload options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "list", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "list", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "list", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "list", "from", &schema.Category{
		Key:         "limit-offset",
		DisplayName: "Limit/Offset options",
		Order:       2147483597,
	})
	AppendFlagCategoryMap("server", "list", "id", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "list", "max", &schema.Category{
		Key:         "limit-offset",
		DisplayName: "Limit/Offset options",
		Order:       2147483597,
	})
	AppendFlagCategoryMap("server", "list", "name", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "list", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "list", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "list", "sort", &schema.Category{
		Key:         "sort",
		DisplayName: "Sort options",
		Order:       2147483607,
	})
	AppendFlagCategoryMap("server", "list", "tags", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "end", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "key-format", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "start", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "end", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "index", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "key-format", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "start", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "end", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "index", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "key-format", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "start", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "plan-change", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "plan-change", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "plan-change", "core", &schema.Category{
		Key:         "plan",
		DisplayName: "Plan options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "plan-change", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "plan-change", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "plan-change", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "plan-change", "memory", &schema.Category{
		Key:         "plan",
		DisplayName: "Plan options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "plan-change", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "plan-change", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "read", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "read", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "read", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "read", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "read", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "read", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "reset", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "reset", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "scp", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "scp", "key", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "scp", "password", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "scp", "port", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "scp", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "scp", "recursive", &schema.Category{
		Key:         "operation",
		DisplayName: "Operation options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "scp", "user", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "shutdown", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "shutdown", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "shutdown-force", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "shutdown-force", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "ssh", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "ssh", "key", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "ssh", "password", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "ssh", "port", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "ssh", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "ssh", "user", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "ssh-exec", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "ssh-exec", "key", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "ssh-exec", "password", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "ssh-exec", "port", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "ssh-exec", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "ssh-exec", "user", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "update", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "update", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "update", "description", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("server", "update", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "update", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "update", "icon-id", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("server", "update", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "update", "name", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("server", "update", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "update", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "update", "tags", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("server", "vnc", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "vnc", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "vnc", "wait-for-boot", &schema.Category{
		Key:         "VNC",
		DisplayName: "VNC options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "vnc-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "vnc-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-info", "wait-for-boot", &schema.Category{
		Key:         "VNC",
		DisplayName: "VNC options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "vnc-send", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "vnc-send", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-send", "command", &schema.Category{
		Key:         "VNC",
		DisplayName: "VNC options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "vnc-send", "command-file", &schema.Category{
		Key:         "VNC",
		DisplayName: "VNC options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "vnc-send", "debug", &schema.Category{
		Key:         "VNC",
		DisplayName: "VNC options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "vnc-send", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-send", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-send", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "vnc-send", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-send", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-send", "use-us-keyboard", &schema.Category{
		Key:         "VNC",
		DisplayName: "VNC options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "vnc-send", "wait-for-boot", &schema.Category{
		Key:         "VNC",
		DisplayName: "VNC options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "wait-for-boot", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "wait-for-down", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})

	// append command to GlobalContext
	Commands = append(Commands, cliCommand)
}
