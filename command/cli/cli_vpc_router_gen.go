// Code generated by 'github.com/sacloud/usacloud/tools/gen-cli-commands'; DO NOT EDIT

package cli

import (
	"fmt"
	"github.com/sacloud/usacloud/command"
	"github.com/sacloud/usacloud/command/completion"
	"github.com/sacloud/usacloud/command/funcs"
	"github.com/sacloud/usacloud/command/params"
	"github.com/sacloud/usacloud/schema"
	"gopkg.in/urfave/cli.v2"
	"strings"
	"sync"
)

func init() {
	listParam := params.NewListVPCRouterParam()
	createParam := params.NewCreateVPCRouterParam()
	readParam := params.NewReadVPCRouterParam()
	updateParam := params.NewUpdateVPCRouterParam()
	deleteParam := params.NewDeleteVPCRouterParam()
	bootParam := params.NewBootVPCRouterParam()
	shutdownParam := params.NewShutdownVPCRouterParam()
	shutdownForceParam := params.NewShutdownForceVPCRouterParam()
	resetParam := params.NewResetVPCRouterParam()
	waitForBootParam := params.NewWaitForBootVPCRouterParam()
	waitForDownParam := params.NewWaitForDownVPCRouterParam()
	interfaceInfoParam := params.NewInterfaceInfoVPCRouterParam()
	interfaceConnectParam := params.NewInterfaceConnectVPCRouterParam()
	interfaceUpdateParam := params.NewInterfaceUpdateVPCRouterParam()
	interfaceDisconnectParam := params.NewInterfaceDisconnectVPCRouterParam()
	staticNatInfoParam := params.NewStaticNatInfoVPCRouterParam()
	staticNatAddParam := params.NewStaticNatAddVPCRouterParam()
	staticNatUpdateParam := params.NewStaticNatUpdateVPCRouterParam()
	staticNatDeleteParam := params.NewStaticNatDeleteVPCRouterParam()
	portForwardingInfoParam := params.NewPortForwardingInfoVPCRouterParam()
	portForwardingAddParam := params.NewPortForwardingAddVPCRouterParam()
	portForwardingUpdateParam := params.NewPortForwardingUpdateVPCRouterParam()
	portForwardingDeleteParam := params.NewPortForwardingDeleteVPCRouterParam()
	firewallInfoParam := params.NewFirewallInfoVPCRouterParam()
	firewallAddParam := params.NewFirewallAddVPCRouterParam()
	firewallUpdateParam := params.NewFirewallUpdateVPCRouterParam()
	firewallDeleteParam := params.NewFirewallDeleteVPCRouterParam()
	dhcpServerInfoParam := params.NewDhcpServerInfoVPCRouterParam()
	dhcpServerAddParam := params.NewDhcpServerAddVPCRouterParam()
	dhcpServerUpdateParam := params.NewDhcpServerUpdateVPCRouterParam()
	dhcpServerDeleteParam := params.NewDhcpServerDeleteVPCRouterParam()
	dhcpStaticMappingInfoParam := params.NewDhcpStaticMappingInfoVPCRouterParam()
	dhcpStaticMappingAddParam := params.NewDhcpStaticMappingAddVPCRouterParam()
	dhcpStaticMappingUpdateParam := params.NewDhcpStaticMappingUpdateVPCRouterParam()
	dhcpStaticMappingDeleteParam := params.NewDhcpStaticMappingDeleteVPCRouterParam()
	pptpServerInfoParam := params.NewPptpServerInfoVPCRouterParam()
	pptpServerUpdateParam := params.NewPptpServerUpdateVPCRouterParam()
	l2tpServerInfoParam := params.NewL2tpServerInfoVPCRouterParam()
	l2tpServerUpdateParam := params.NewL2tpServerUpdateVPCRouterParam()
	userInfoParam := params.NewUserInfoVPCRouterParam()
	userAddParam := params.NewUserAddVPCRouterParam()
	userUpdateParam := params.NewUserUpdateVPCRouterParam()
	userDeleteParam := params.NewUserDeleteVPCRouterParam()
	siteToSiteVpnInfoParam := params.NewSiteToSiteVpnInfoVPCRouterParam()
	siteToSiteVpnAddParam := params.NewSiteToSiteVpnAddVPCRouterParam()
	siteToSiteVpnUpdateParam := params.NewSiteToSiteVpnUpdateVPCRouterParam()
	siteToSiteVpnDeleteParam := params.NewSiteToSiteVpnDeleteVPCRouterParam()
	staticRouteInfoParam := params.NewStaticRouteInfoVPCRouterParam()
	staticRouteAddParam := params.NewStaticRouteAddVPCRouterParam()
	staticRouteUpdateParam := params.NewStaticRouteUpdateVPCRouterParam()
	staticRouteDeleteParam := params.NewStaticRouteDeleteVPCRouterParam()
	monitorParam := params.NewMonitorVPCRouterParam()

	cliCommand := &cli.Command{
		Name:  "vpc-router",
		Usage: "A manage commands of VPCRouter",
		Subcommands: []*cli.Command{
			{
				Name:    "list",
				Aliases: []string{"ls", "find"},
				Usage:   "List VPCRouter",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "name",
						Usage: "set filter by name(s)",
					},
					&cli.Int64SliceFlag{
						Name:  "id",
						Usage: "set filter by id(s)",
					},
					&cli.StringSliceFlag{
						Name:  "tags",
						Usage: "set filter by tags(AND)",
					},
					&cli.IntFlag{
						Name:        "from",
						Aliases:     []string{"offset"},
						Usage:       "set offset",
						Destination: &listParam.From,
					},
					&cli.IntFlag{
						Name:        "max",
						Aliases:     []string{"limit"},
						Usage:       "set limit",
						Destination: &listParam.Max,
					},
					&cli.StringSliceFlag{
						Name:  "sort",
						Usage: "set field(s) for sort",
					},
					&cli.StringFlag{
						Name:        "output-type",
						Aliases:     []string{"out"},
						Usage:       "Output type [json/csv/tsv]",
						Destination: &listParam.OutputType,
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:        "quiet",
						Aliases:     []string{"q"},
						Usage:       "Only display IDs",
						Destination: &listParam.Quiet,
					},
					&cli.StringFlag{
						Name:        "format",
						Aliases:     []string{"fmt"},
						Usage:       "Output format(see text/template package document for detail)",
						Destination: &listParam.Format,
					},
					&cli.StringFlag{
						Name:        "format-file",
						Usage:       "Output format from file(see text/template package document for detail)",
						Destination: &listParam.FormatFile,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, listParam)

					// Set option values for slice
					listParam.Name = c.StringSlice("name")
					listParam.Id = c.Int64Slice("id")
					listParam.Tags = c.StringSlice("tags")
					listParam.Sort = c.StringSlice("sort")
					listParam.Column = c.StringSlice("column")

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterListCompleteArgs(ctx, listParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterListCompleteArgs(ctx, listParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterListCompleteFlags(ctx, listParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterListCompleteArgs(ctx, listParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Set option values for slice
					listParam.Name = c.StringSlice("name")
					listParam.Id = c.Int64Slice("id")
					listParam.Tags = c.StringSlice("tags")
					listParam.Sort = c.StringSlice("sort")
					listParam.Column = c.StringSlice("column")

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := listParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), listParam)

					// Run command with params
					return funcs.VPCRouterList(ctx, listParam)

				},
			},
			{
				Name:  "create",
				Usage: "Create VPCRouter",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "plan",
						Usage:       "[Required] set plan[standard/premium/highspec]",
						Value:       "standard",
						Destination: &createParam.Plan,
					},
					&cli.Int64Flag{
						Name:        "switch-id",
						Usage:       "set connect switch ID",
						Destination: &createParam.SwitchId,
					},
					&cli.IntFlag{
						Name:        "vrid",
						Aliases:     []string{"VRID"},
						Usage:       "[Required] set VRID",
						Value:       1,
						Destination: &createParam.Vrid,
					},
					&cli.StringFlag{
						Name:        "vip",
						Usage:       "set virtual ipddress()",
						Destination: &createParam.Vip,
					},
					&cli.StringFlag{
						Name:        "ipaddress1",
						Aliases:     []string{"ip1"},
						Usage:       "set ipaddress(#1)",
						Destination: &createParam.Ipaddress1,
					},
					&cli.StringFlag{
						Name:        "ipaddress2",
						Aliases:     []string{"ip2"},
						Usage:       "set ipaddress(#2)",
						Destination: &createParam.Ipaddress2,
					},
					&cli.BoolFlag{
						Name:        "boot-after-create",
						Usage:       "boot after create",
						Value:       false,
						Destination: &createParam.BootAfterCreate,
					},
					&cli.StringFlag{
						Name:        "name",
						Usage:       "[Required] set resource display name",
						Destination: &createParam.Name,
					},
					&cli.StringFlag{
						Name:        "description",
						Aliases:     []string{"desc"},
						Usage:       "set resource description",
						Destination: &createParam.Description,
					},
					&cli.StringSliceFlag{
						Name:  "tags",
						Usage: "set resource tags",
					},
					&cli.Int64Flag{
						Name:        "icon-id",
						Usage:       "set Icon ID",
						Destination: &createParam.IconId,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &createParam.Assumeyes,
					},
					&cli.StringFlag{
						Name:        "output-type",
						Aliases:     []string{"out"},
						Usage:       "Output type [json/csv/tsv]",
						Destination: &createParam.OutputType,
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:        "quiet",
						Aliases:     []string{"q"},
						Usage:       "Only display IDs",
						Destination: &createParam.Quiet,
					},
					&cli.StringFlag{
						Name:        "format",
						Aliases:     []string{"fmt"},
						Usage:       "Output format(see text/template package document for detail)",
						Destination: &createParam.Format,
					},
					&cli.StringFlag{
						Name:        "format-file",
						Usage:       "Output format from file(see text/template package document for detail)",
						Destination: &createParam.FormatFile,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, createParam)

					// Set option values for slice
					createParam.Tags = c.StringSlice("tags")
					createParam.Column = c.StringSlice("column")

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterCreateCompleteArgs(ctx, createParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterCreateCompleteArgs(ctx, createParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterCreateCompleteFlags(ctx, createParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterCreateCompleteArgs(ctx, createParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Set option values for slice
					createParam.Tags = c.StringSlice("tags")
					createParam.Column = c.StringSlice("column")

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := createParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), createParam)

					// confirm
					if !createParam.Assumeyes && !command.ConfirmContinue("create") {
						return nil
					}

					// Run command with params
					return funcs.VPCRouterCreate(ctx, createParam)

				},
			},
			{
				Name:      "read",
				Usage:     "Read VPCRouter",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "output-type",
						Aliases:     []string{"out"},
						Usage:       "Output type [json/csv/tsv]",
						Destination: &readParam.OutputType,
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:        "quiet",
						Aliases:     []string{"q"},
						Usage:       "Only display IDs",
						Destination: &readParam.Quiet,
					},
					&cli.StringFlag{
						Name:        "format",
						Aliases:     []string{"fmt"},
						Usage:       "Output format(see text/template package document for detail)",
						Destination: &readParam.Format,
					},
					&cli.StringFlag{
						Name:        "format-file",
						Usage:       "Output format from file(see text/template package document for detail)",
						Destination: &readParam.FormatFile,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &readParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, readParam)

					// Set option values for slice
					readParam.Column = c.StringSlice("column")

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterReadCompleteArgs(ctx, readParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterReadCompleteArgs(ctx, readParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterReadCompleteFlags(ctx, readParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterReadCompleteArgs(ctx, readParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Set option values for slice
					readParam.Column = c.StringSlice("column")

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := readParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), readParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						readParam.SetId(id)
						p := *readParam // copy struct value
						readParam := &p
						go func() {
							err := funcs.VPCRouterRead(ctx, readParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "update",
				Usage:     "Update VPCRouter",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "syslog-host",
						Usage:       "set syslog host IPAddress",
						Destination: &updateParam.SyslogHost,
					},
					&cli.StringFlag{
						Name:        "name",
						Usage:       "set resource display name",
						Destination: &updateParam.Name,
					},
					&cli.StringFlag{
						Name:        "description",
						Aliases:     []string{"desc"},
						Usage:       "set resource description",
						Destination: &updateParam.Description,
					},
					&cli.StringSliceFlag{
						Name:  "tags",
						Usage: "set resource tags",
					},
					&cli.Int64Flag{
						Name:        "icon-id",
						Usage:       "set Icon ID",
						Destination: &updateParam.IconId,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &updateParam.Assumeyes,
					},
					&cli.StringFlag{
						Name:        "output-type",
						Aliases:     []string{"out"},
						Usage:       "Output type [json/csv/tsv]",
						Destination: &updateParam.OutputType,
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:        "quiet",
						Aliases:     []string{"q"},
						Usage:       "Only display IDs",
						Destination: &updateParam.Quiet,
					},
					&cli.StringFlag{
						Name:        "format",
						Aliases:     []string{"fmt"},
						Usage:       "Output format(see text/template package document for detail)",
						Destination: &updateParam.Format,
					},
					&cli.StringFlag{
						Name:        "format-file",
						Usage:       "Output format from file(see text/template package document for detail)",
						Destination: &updateParam.FormatFile,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &updateParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, updateParam)

					// Set option values for slice
					updateParam.Tags = c.StringSlice("tags")
					updateParam.Column = c.StringSlice("column")

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterUpdateCompleteArgs(ctx, updateParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterUpdateCompleteArgs(ctx, updateParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterUpdateCompleteFlags(ctx, updateParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterUpdateCompleteArgs(ctx, updateParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Set option values for slice
					updateParam.Tags = c.StringSlice("tags")
					updateParam.Column = c.StringSlice("column")

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := updateParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), updateParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					// confirm
					if !updateParam.Assumeyes && !command.ConfirmContinue("update", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						updateParam.SetId(id)
						p := *updateParam // copy struct value
						updateParam := &p
						go func() {
							err := funcs.VPCRouterUpdate(ctx, updateParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "delete",
				Aliases:   []string{"rm"},
				Usage:     "Delete VPCRouter",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.BoolFlag{
						Name:        "force",
						Aliases:     []string{"f"},
						Usage:       "forced-shutdown flag if server is running",
						Destination: &deleteParam.Force,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &deleteParam.Assumeyes,
					},
					&cli.StringFlag{
						Name:        "output-type",
						Aliases:     []string{"out"},
						Usage:       "Output type [json/csv/tsv]",
						Destination: &deleteParam.OutputType,
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:        "quiet",
						Aliases:     []string{"q"},
						Usage:       "Only display IDs",
						Destination: &deleteParam.Quiet,
					},
					&cli.StringFlag{
						Name:        "format",
						Aliases:     []string{"fmt"},
						Usage:       "Output format(see text/template package document for detail)",
						Destination: &deleteParam.Format,
					},
					&cli.StringFlag{
						Name:        "format-file",
						Usage:       "Output format from file(see text/template package document for detail)",
						Destination: &deleteParam.FormatFile,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &deleteParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, deleteParam)

					// Set option values for slice
					deleteParam.Column = c.StringSlice("column")

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterDeleteCompleteArgs(ctx, deleteParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterDeleteCompleteArgs(ctx, deleteParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterDeleteCompleteFlags(ctx, deleteParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterDeleteCompleteArgs(ctx, deleteParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Set option values for slice
					deleteParam.Column = c.StringSlice("column")

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := deleteParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), deleteParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					// confirm
					if !deleteParam.Assumeyes && !command.ConfirmContinue("delete", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						deleteParam.SetId(id)
						p := *deleteParam // copy struct value
						deleteParam := &p
						go func() {
							err := funcs.VPCRouterDelete(ctx, deleteParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "boot",
				Aliases:   []string{"power-on"},
				Usage:     "Boot VPCRouter",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &bootParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &bootParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, bootParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterBootCompleteArgs(ctx, bootParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterBootCompleteArgs(ctx, bootParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterBootCompleteFlags(ctx, bootParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterBootCompleteArgs(ctx, bootParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := bootParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), bootParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					// confirm
					if !bootParam.Assumeyes && !command.ConfirmContinue("boot", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						bootParam.SetId(id)
						p := *bootParam // copy struct value
						bootParam := &p
						go func() {
							err := funcs.VPCRouterBoot(ctx, bootParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "shutdown",
				Aliases:   []string{"power-off"},
				Usage:     "Shutdown VPCRouter",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &shutdownParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &shutdownParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, shutdownParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterShutdownCompleteArgs(ctx, shutdownParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterShutdownCompleteArgs(ctx, shutdownParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterShutdownCompleteFlags(ctx, shutdownParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterShutdownCompleteArgs(ctx, shutdownParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := shutdownParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), shutdownParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					// confirm
					if !shutdownParam.Assumeyes && !command.ConfirmContinue("shutdown", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						shutdownParam.SetId(id)
						p := *shutdownParam // copy struct value
						shutdownParam := &p
						go func() {
							err := funcs.VPCRouterShutdown(ctx, shutdownParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "shutdown-force",
				Aliases:   []string{"stop"},
				Usage:     "ShutdownForce VPCRouter",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &shutdownForceParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &shutdownForceParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, shutdownForceParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterShutdownForceCompleteArgs(ctx, shutdownForceParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterShutdownForceCompleteArgs(ctx, shutdownForceParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterShutdownForceCompleteFlags(ctx, shutdownForceParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterShutdownForceCompleteArgs(ctx, shutdownForceParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := shutdownForceParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), shutdownForceParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					// confirm
					if !shutdownForceParam.Assumeyes && !command.ConfirmContinue("shutdown-force", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						shutdownForceParam.SetId(id)
						p := *shutdownForceParam // copy struct value
						shutdownForceParam := &p
						go func() {
							err := funcs.VPCRouterShutdownForce(ctx, shutdownForceParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "reset",
				Usage:     "Reset VPCRouter",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &resetParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &resetParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, resetParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterResetCompleteArgs(ctx, resetParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterResetCompleteArgs(ctx, resetParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterResetCompleteFlags(ctx, resetParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterResetCompleteArgs(ctx, resetParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := resetParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), resetParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					// confirm
					if !resetParam.Assumeyes && !command.ConfirmContinue("reset", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						resetParam.SetId(id)
						p := *resetParam // copy struct value
						resetParam := &p
						go func() {
							err := funcs.VPCRouterReset(ctx, resetParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "wait-for-boot",
				Usage:     "Wait until boot is completed",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &waitForBootParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, waitForBootParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterWaitForBootCompleteArgs(ctx, waitForBootParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterWaitForBootCompleteArgs(ctx, waitForBootParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterWaitForBootCompleteFlags(ctx, waitForBootParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterWaitForBootCompleteArgs(ctx, waitForBootParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := waitForBootParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), waitForBootParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						waitForBootParam.SetId(id)
						p := *waitForBootParam // copy struct value
						waitForBootParam := &p
						go func() {
							err := funcs.VPCRouterWaitForBoot(ctx, waitForBootParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "wait-for-down",
				Usage:     "Wait until shutdown is completed",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &waitForDownParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, waitForDownParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterWaitForDownCompleteArgs(ctx, waitForDownParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterWaitForDownCompleteArgs(ctx, waitForDownParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterWaitForDownCompleteFlags(ctx, waitForDownParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterWaitForDownCompleteArgs(ctx, waitForDownParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := waitForDownParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), waitForDownParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						waitForDownParam.SetId(id)
						p := *waitForDownParam // copy struct value
						waitForDownParam := &p
						go func() {
							err := funcs.VPCRouterWaitForDown(ctx, waitForDownParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "interface-info",
				Aliases:   []string{"interface-list"},
				Usage:     "Show information of NIC(s) connected to vpc-router",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "output-type",
						Aliases:     []string{"out"},
						Usage:       "Output type [json/csv/tsv]",
						Destination: &interfaceInfoParam.OutputType,
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:        "quiet",
						Aliases:     []string{"q"},
						Usage:       "Only display IDs",
						Destination: &interfaceInfoParam.Quiet,
					},
					&cli.StringFlag{
						Name:        "format",
						Aliases:     []string{"fmt"},
						Usage:       "Output format(see text/template package document for detail)",
						Destination: &interfaceInfoParam.Format,
					},
					&cli.StringFlag{
						Name:        "format-file",
						Usage:       "Output format from file(see text/template package document for detail)",
						Destination: &interfaceInfoParam.FormatFile,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &interfaceInfoParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, interfaceInfoParam)

					// Set option values for slice
					interfaceInfoParam.Column = c.StringSlice("column")

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterInterfaceInfoCompleteArgs(ctx, interfaceInfoParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterInterfaceInfoCompleteArgs(ctx, interfaceInfoParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterInterfaceInfoCompleteFlags(ctx, interfaceInfoParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterInterfaceInfoCompleteArgs(ctx, interfaceInfoParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Set option values for slice
					interfaceInfoParam.Column = c.StringSlice("column")

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := interfaceInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), interfaceInfoParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						interfaceInfoParam.SetId(id)
						p := *interfaceInfoParam // copy struct value
						interfaceInfoParam := &p
						go func() {
							err := funcs.VPCRouterInterfaceInfo(ctx, interfaceInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "interface-connect",
				Usage:     "Connected to switch",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "index",
						Usage:       "[Required] index of target private-interface",
						Destination: &interfaceConnectParam.Index,
					},
					&cli.StringFlag{
						Name:        "ipaddress",
						Aliases:     []string{"ip", "vip"},
						Usage:       "[Required] set (virtual)ipaddress",
						Destination: &interfaceConnectParam.Ipaddress,
					},
					&cli.BoolFlag{
						Name:        "with-reboot",
						Usage:       "reboot after connect",
						Destination: &interfaceConnectParam.WithReboot,
					},
					&cli.StringFlag{
						Name:        "ipaddress1",
						Aliases:     []string{"ip1"},
						Usage:       "set ipaddress(#1)",
						Destination: &interfaceConnectParam.Ipaddress1,
					},
					&cli.Int64Flag{
						Name:        "switch-id",
						Usage:       "[Required] set connect switch ID",
						Destination: &interfaceConnectParam.SwitchId,
					},
					&cli.StringFlag{
						Name:        "ipaddress2",
						Aliases:     []string{"ip2"},
						Usage:       "set ipaddress(#2)",
						Destination: &interfaceConnectParam.Ipaddress2,
					},
					&cli.IntFlag{
						Name:        "nw-masklen",
						Aliases:     []string{"network-masklen"},
						Usage:       "set ipaddress prefix",
						Value:       24,
						Destination: &interfaceConnectParam.NwMasklen,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &interfaceConnectParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &interfaceConnectParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, interfaceConnectParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterInterfaceConnectCompleteArgs(ctx, interfaceConnectParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterInterfaceConnectCompleteArgs(ctx, interfaceConnectParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterInterfaceConnectCompleteFlags(ctx, interfaceConnectParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterInterfaceConnectCompleteArgs(ctx, interfaceConnectParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := interfaceConnectParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), interfaceConnectParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !interfaceConnectParam.Assumeyes && !command.ConfirmContinue("interface-connect", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						interfaceConnectParam.SetId(id)
						p := *interfaceConnectParam // copy struct value
						interfaceConnectParam := &p
						go func() {
							err := funcs.VPCRouterInterfaceConnect(ctx, interfaceConnectParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "interface-update",
				Usage:     "Update interface",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "index",
						Usage:       "[Required] index of target interface",
						Destination: &interfaceUpdateParam.Index,
					},
					&cli.StringFlag{
						Name:        "ipaddress",
						Aliases:     []string{"ip", "vip"},
						Usage:       "set (virtual)ipaddress",
						Destination: &interfaceUpdateParam.Ipaddress,
					},
					&cli.BoolFlag{
						Name:        "with-reboot",
						Usage:       "reboot after connect",
						Destination: &interfaceUpdateParam.WithReboot,
					},
					&cli.StringFlag{
						Name:        "ipaddress1",
						Aliases:     []string{"ip1"},
						Usage:       "set ipaddress(#1)",
						Destination: &interfaceUpdateParam.Ipaddress1,
					},
					&cli.Int64Flag{
						Name:        "switch-id",
						Usage:       "set connect switch ID",
						Destination: &interfaceUpdateParam.SwitchId,
					},
					&cli.StringFlag{
						Name:        "ipaddress2",
						Aliases:     []string{"ip2"},
						Usage:       "set ipaddress(#2)",
						Destination: &interfaceUpdateParam.Ipaddress2,
					},
					&cli.StringSliceFlag{
						Name:  "alias",
						Usage: "set ip aliases",
					},
					&cli.IntFlag{
						Name:        "nw-masklen",
						Aliases:     []string{"network-masklen"},
						Usage:       "set ipaddress prefix",
						Value:       24,
						Destination: &interfaceUpdateParam.NwMasklen,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &interfaceUpdateParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &interfaceUpdateParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, interfaceUpdateParam)

					// Set option values for slice
					interfaceUpdateParam.Alias = c.StringSlice("alias")

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterInterfaceUpdateCompleteArgs(ctx, interfaceUpdateParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterInterfaceUpdateCompleteArgs(ctx, interfaceUpdateParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterInterfaceUpdateCompleteFlags(ctx, interfaceUpdateParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterInterfaceUpdateCompleteArgs(ctx, interfaceUpdateParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Set option values for slice
					interfaceUpdateParam.Alias = c.StringSlice("alias")

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := interfaceUpdateParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), interfaceUpdateParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !interfaceUpdateParam.Assumeyes && !command.ConfirmContinue("interface-update", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						interfaceUpdateParam.SetId(id)
						p := *interfaceUpdateParam // copy struct value
						interfaceUpdateParam := &p
						go func() {
							err := funcs.VPCRouterInterfaceUpdate(ctx, interfaceUpdateParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "interface-disconnect",
				Usage:     "Disconnected to switch",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "index",
						Usage:       "[Required] index of target private-interface",
						Destination: &interfaceDisconnectParam.Index,
					},
					&cli.BoolFlag{
						Name:        "with-reboot",
						Usage:       "reboot after connect",
						Destination: &interfaceDisconnectParam.WithReboot,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &interfaceDisconnectParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &interfaceDisconnectParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, interfaceDisconnectParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterInterfaceDisconnectCompleteArgs(ctx, interfaceDisconnectParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterInterfaceDisconnectCompleteArgs(ctx, interfaceDisconnectParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterInterfaceDisconnectCompleteFlags(ctx, interfaceDisconnectParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterInterfaceDisconnectCompleteArgs(ctx, interfaceDisconnectParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := interfaceDisconnectParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), interfaceDisconnectParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !interfaceDisconnectParam.Assumeyes && !command.ConfirmContinue("interface-disconnect", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						interfaceDisconnectParam.SetId(id)
						p := *interfaceDisconnectParam // copy struct value
						interfaceDisconnectParam := &p
						go func() {
							err := funcs.VPCRouterInterfaceDisconnect(ctx, interfaceDisconnectParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "static-nat-info",
				Aliases:   []string{"static-nat-list"},
				Usage:     "Show information of static NAT settings",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "output-type",
						Aliases:     []string{"out"},
						Usage:       "Output type [json/csv/tsv]",
						Destination: &staticNatInfoParam.OutputType,
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:        "quiet",
						Aliases:     []string{"q"},
						Usage:       "Only display IDs",
						Destination: &staticNatInfoParam.Quiet,
					},
					&cli.StringFlag{
						Name:        "format",
						Aliases:     []string{"fmt"},
						Usage:       "Output format(see text/template package document for detail)",
						Destination: &staticNatInfoParam.Format,
					},
					&cli.StringFlag{
						Name:        "format-file",
						Usage:       "Output format from file(see text/template package document for detail)",
						Destination: &staticNatInfoParam.FormatFile,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &staticNatInfoParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, staticNatInfoParam)

					// Set option values for slice
					staticNatInfoParam.Column = c.StringSlice("column")

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterStaticNatInfoCompleteArgs(ctx, staticNatInfoParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterStaticNatInfoCompleteArgs(ctx, staticNatInfoParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterStaticNatInfoCompleteFlags(ctx, staticNatInfoParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterStaticNatInfoCompleteArgs(ctx, staticNatInfoParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Set option values for slice
					staticNatInfoParam.Column = c.StringSlice("column")

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := staticNatInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), staticNatInfoParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						staticNatInfoParam.SetId(id)
						p := *staticNatInfoParam // copy struct value
						staticNatInfoParam := &p
						go func() {
							err := funcs.VPCRouterStaticNatInfo(ctx, staticNatInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "static-nat-add",
				Usage:     "Add static NAT",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "global",
						Aliases:     []string{"global-ip", "global-address"},
						Usage:       "[Required] set global ipaddress",
						Destination: &staticNatAddParam.Global,
					},
					&cli.StringFlag{
						Name:        "private",
						Aliases:     []string{"private-ip", "private-address"},
						Usage:       "[Required] set private ipaddress",
						Destination: &staticNatAddParam.Private,
					},
					&cli.StringFlag{
						Name:        "description",
						Aliases:     []string{"desc"},
						Usage:       "set description",
						Destination: &staticNatAddParam.Description,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &staticNatAddParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &staticNatAddParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, staticNatAddParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterStaticNatAddCompleteArgs(ctx, staticNatAddParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterStaticNatAddCompleteArgs(ctx, staticNatAddParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterStaticNatAddCompleteFlags(ctx, staticNatAddParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterStaticNatAddCompleteArgs(ctx, staticNatAddParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := staticNatAddParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), staticNatAddParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !staticNatAddParam.Assumeyes && !command.ConfirmContinue("static-nat-add", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						staticNatAddParam.SetId(id)
						p := *staticNatAddParam // copy struct value
						staticNatAddParam := &p
						go func() {
							err := funcs.VPCRouterStaticNatAdd(ctx, staticNatAddParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "static-nat-update",
				Usage:     "Update static NAT",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:        "index",
						Usage:       "[Required] index of target static NAT",
						Destination: &staticNatUpdateParam.Index,
					},
					&cli.StringFlag{
						Name:        "global",
						Aliases:     []string{"global-ip", "global-address"},
						Usage:       "set global ipaddress",
						Destination: &staticNatUpdateParam.Global,
					},
					&cli.StringFlag{
						Name:        "private",
						Aliases:     []string{"private-ip", "private-address"},
						Usage:       "set private ipaddress",
						Destination: &staticNatUpdateParam.Private,
					},
					&cli.StringFlag{
						Name:        "description",
						Aliases:     []string{"desc"},
						Usage:       "set description",
						Destination: &staticNatUpdateParam.Description,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &staticNatUpdateParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &staticNatUpdateParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, staticNatUpdateParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterStaticNatUpdateCompleteArgs(ctx, staticNatUpdateParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterStaticNatUpdateCompleteArgs(ctx, staticNatUpdateParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterStaticNatUpdateCompleteFlags(ctx, staticNatUpdateParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterStaticNatUpdateCompleteArgs(ctx, staticNatUpdateParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := staticNatUpdateParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), staticNatUpdateParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !staticNatUpdateParam.Assumeyes && !command.ConfirmContinue("static-nat-update", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						staticNatUpdateParam.SetId(id)
						p := *staticNatUpdateParam // copy struct value
						staticNatUpdateParam := &p
						go func() {
							err := funcs.VPCRouterStaticNatUpdate(ctx, staticNatUpdateParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "static-nat-delete",
				Usage:     "Delete static NAT",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:        "index",
						Usage:       "[Required] index of target static NAT",
						Destination: &staticNatDeleteParam.Index,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &staticNatDeleteParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &staticNatDeleteParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, staticNatDeleteParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterStaticNatDeleteCompleteArgs(ctx, staticNatDeleteParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterStaticNatDeleteCompleteArgs(ctx, staticNatDeleteParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterStaticNatDeleteCompleteFlags(ctx, staticNatDeleteParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterStaticNatDeleteCompleteArgs(ctx, staticNatDeleteParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := staticNatDeleteParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), staticNatDeleteParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !staticNatDeleteParam.Assumeyes && !command.ConfirmContinue("static-nat-delete", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						staticNatDeleteParam.SetId(id)
						p := *staticNatDeleteParam // copy struct value
						staticNatDeleteParam := &p
						go func() {
							err := funcs.VPCRouterStaticNatDelete(ctx, staticNatDeleteParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "port-forwarding-info",
				Aliases:   []string{"port-forwarding-list"},
				Usage:     "Show information of port-forwarding settings",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "output-type",
						Aliases:     []string{"out"},
						Usage:       "Output type [json/csv/tsv]",
						Destination: &portForwardingInfoParam.OutputType,
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:        "quiet",
						Aliases:     []string{"q"},
						Usage:       "Only display IDs",
						Destination: &portForwardingInfoParam.Quiet,
					},
					&cli.StringFlag{
						Name:        "format",
						Aliases:     []string{"fmt"},
						Usage:       "Output format(see text/template package document for detail)",
						Destination: &portForwardingInfoParam.Format,
					},
					&cli.StringFlag{
						Name:        "format-file",
						Usage:       "Output format from file(see text/template package document for detail)",
						Destination: &portForwardingInfoParam.FormatFile,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &portForwardingInfoParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, portForwardingInfoParam)

					// Set option values for slice
					portForwardingInfoParam.Column = c.StringSlice("column")

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterPortForwardingInfoCompleteArgs(ctx, portForwardingInfoParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterPortForwardingInfoCompleteArgs(ctx, portForwardingInfoParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterPortForwardingInfoCompleteFlags(ctx, portForwardingInfoParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterPortForwardingInfoCompleteArgs(ctx, portForwardingInfoParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Set option values for slice
					portForwardingInfoParam.Column = c.StringSlice("column")

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := portForwardingInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), portForwardingInfoParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						portForwardingInfoParam.SetId(id)
						p := *portForwardingInfoParam // copy struct value
						portForwardingInfoParam := &p
						go func() {
							err := funcs.VPCRouterPortForwardingInfo(ctx, portForwardingInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "port-forwarding-add",
				Usage:     "Add port forwarding",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "protocol",
						Usage:       "[Required] set target protocol",
						Destination: &portForwardingAddParam.Protocol,
					},
					&cli.IntFlag{
						Name:        "global-port",
						Usage:       "[Required] set global ipaddress",
						Destination: &portForwardingAddParam.GlobalPort,
					},
					&cli.StringFlag{
						Name:        "private-ipaddress",
						Aliases:     []string{"private-ip", "private-address"},
						Usage:       "[Required] set private ipaddress",
						Destination: &portForwardingAddParam.PrivateIpaddress,
					},
					&cli.IntFlag{
						Name:        "private-port",
						Usage:       "[Required] set private ipaddress",
						Destination: &portForwardingAddParam.PrivatePort,
					},
					&cli.StringFlag{
						Name:        "description",
						Aliases:     []string{"desc"},
						Usage:       "set description",
						Destination: &portForwardingAddParam.Description,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &portForwardingAddParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &portForwardingAddParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, portForwardingAddParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterPortForwardingAddCompleteArgs(ctx, portForwardingAddParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterPortForwardingAddCompleteArgs(ctx, portForwardingAddParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterPortForwardingAddCompleteFlags(ctx, portForwardingAddParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterPortForwardingAddCompleteArgs(ctx, portForwardingAddParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := portForwardingAddParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), portForwardingAddParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !portForwardingAddParam.Assumeyes && !command.ConfirmContinue("port-forwarding-add", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						portForwardingAddParam.SetId(id)
						p := *portForwardingAddParam // copy struct value
						portForwardingAddParam := &p
						go func() {
							err := funcs.VPCRouterPortForwardingAdd(ctx, portForwardingAddParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "port-forwarding-update",
				Usage:     "Update port forwarding",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:        "index",
						Usage:       "[Required] index of target static NAT",
						Destination: &portForwardingUpdateParam.Index,
					},
					&cli.StringFlag{
						Name:        "protocol",
						Usage:       "set target protocol",
						Destination: &portForwardingUpdateParam.Protocol,
					},
					&cli.IntFlag{
						Name:        "global-port",
						Usage:       "set global ipaddress",
						Destination: &portForwardingUpdateParam.GlobalPort,
					},
					&cli.StringFlag{
						Name:        "private-ipaddress",
						Aliases:     []string{"private-ip", "private-address"},
						Usage:       "set private ipaddress",
						Destination: &portForwardingUpdateParam.PrivateIpaddress,
					},
					&cli.IntFlag{
						Name:        "private-port",
						Usage:       "set private ipaddress",
						Destination: &portForwardingUpdateParam.PrivatePort,
					},
					&cli.StringFlag{
						Name:        "description",
						Aliases:     []string{"desc"},
						Usage:       "set description",
						Destination: &portForwardingUpdateParam.Description,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &portForwardingUpdateParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &portForwardingUpdateParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, portForwardingUpdateParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterPortForwardingUpdateCompleteArgs(ctx, portForwardingUpdateParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterPortForwardingUpdateCompleteArgs(ctx, portForwardingUpdateParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterPortForwardingUpdateCompleteFlags(ctx, portForwardingUpdateParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterPortForwardingUpdateCompleteArgs(ctx, portForwardingUpdateParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := portForwardingUpdateParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), portForwardingUpdateParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !portForwardingUpdateParam.Assumeyes && !command.ConfirmContinue("port-forwarding-update", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						portForwardingUpdateParam.SetId(id)
						p := *portForwardingUpdateParam // copy struct value
						portForwardingUpdateParam := &p
						go func() {
							err := funcs.VPCRouterPortForwardingUpdate(ctx, portForwardingUpdateParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "port-forwarding-delete",
				Usage:     "Delete port forwarding",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:        "index",
						Usage:       "[Required] index of target static NAT",
						Destination: &portForwardingDeleteParam.Index,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &portForwardingDeleteParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &portForwardingDeleteParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, portForwardingDeleteParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterPortForwardingDeleteCompleteArgs(ctx, portForwardingDeleteParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterPortForwardingDeleteCompleteArgs(ctx, portForwardingDeleteParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterPortForwardingDeleteCompleteFlags(ctx, portForwardingDeleteParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterPortForwardingDeleteCompleteArgs(ctx, portForwardingDeleteParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := portForwardingDeleteParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), portForwardingDeleteParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !portForwardingDeleteParam.Assumeyes && !command.ConfirmContinue("port-forwarding-delete", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						portForwardingDeleteParam.SetId(id)
						p := *portForwardingDeleteParam // copy struct value
						portForwardingDeleteParam := &p
						go func() {
							err := funcs.VPCRouterPortForwardingDelete(ctx, portForwardingDeleteParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "firewall-info",
				Aliases:   []string{"firewall-list"},
				Usage:     "Show information of firewall rules",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "direction",
						Usage:       "[Required] set target direction[send/receive]",
						Value:       "receive",
						Destination: &firewallInfoParam.Direction,
					},
					&cli.StringFlag{
						Name:        "output-type",
						Aliases:     []string{"out"},
						Usage:       "Output type [json/csv/tsv]",
						Destination: &firewallInfoParam.OutputType,
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:        "quiet",
						Aliases:     []string{"q"},
						Usage:       "Only display IDs",
						Destination: &firewallInfoParam.Quiet,
					},
					&cli.StringFlag{
						Name:        "format",
						Aliases:     []string{"fmt"},
						Usage:       "Output format(see text/template package document for detail)",
						Destination: &firewallInfoParam.Format,
					},
					&cli.StringFlag{
						Name:        "format-file",
						Usage:       "Output format from file(see text/template package document for detail)",
						Destination: &firewallInfoParam.FormatFile,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &firewallInfoParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, firewallInfoParam)

					// Set option values for slice
					firewallInfoParam.Column = c.StringSlice("column")

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterFirewallInfoCompleteArgs(ctx, firewallInfoParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterFirewallInfoCompleteArgs(ctx, firewallInfoParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterFirewallInfoCompleteFlags(ctx, firewallInfoParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterFirewallInfoCompleteArgs(ctx, firewallInfoParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Set option values for slice
					firewallInfoParam.Column = c.StringSlice("column")

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := firewallInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), firewallInfoParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						firewallInfoParam.SetId(id)
						p := *firewallInfoParam // copy struct value
						firewallInfoParam := &p
						go func() {
							err := funcs.VPCRouterFirewallInfo(ctx, firewallInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "firewall-add",
				Usage:     "Add firewall rule",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "direction",
						Usage:       "[Required] set target direction[send/receive]",
						Value:       "receive",
						Destination: &firewallAddParam.Direction,
					},
					&cli.StringFlag{
						Name:        "protocol",
						Usage:       "[Required] set target protocol",
						Destination: &firewallAddParam.Protocol,
					},
					&cli.StringFlag{
						Name:        "source-network",
						Usage:       "set source ipaddress or network address",
						Destination: &firewallAddParam.SourceNetwork,
					},
					&cli.IntFlag{
						Name:        "source-port",
						Usage:       "set source port",
						Destination: &firewallAddParam.SourcePort,
					},
					&cli.StringFlag{
						Name:        "destination-network",
						Aliases:     []string{"dest-network"},
						Usage:       "set destination ipaddress or network address",
						Destination: &firewallAddParam.DestinationNetwork,
					},
					&cli.IntFlag{
						Name:        "destination-port",
						Aliases:     []string{"dest-port"},
						Usage:       "set destination port",
						Destination: &firewallAddParam.DestinationPort,
					},
					&cli.StringFlag{
						Name:        "action",
						Usage:       "[Required] set action[allow/deny]",
						Value:       "deny",
						Destination: &firewallAddParam.Action,
					},
					&cli.BoolFlag{
						Name:        "enable-logging",
						Usage:       "enable logging",
						Destination: &firewallAddParam.EnableLogging,
					},
					&cli.StringFlag{
						Name:        "description",
						Aliases:     []string{"desc"},
						Usage:       "set description",
						Destination: &firewallAddParam.Description,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &firewallAddParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &firewallAddParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, firewallAddParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterFirewallAddCompleteArgs(ctx, firewallAddParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterFirewallAddCompleteArgs(ctx, firewallAddParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterFirewallAddCompleteFlags(ctx, firewallAddParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterFirewallAddCompleteArgs(ctx, firewallAddParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := firewallAddParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), firewallAddParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !firewallAddParam.Assumeyes && !command.ConfirmContinue("firewall-add", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						firewallAddParam.SetId(id)
						p := *firewallAddParam // copy struct value
						firewallAddParam := &p
						go func() {
							err := funcs.VPCRouterFirewallAdd(ctx, firewallAddParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "firewall-update",
				Usage:     "Update firewall rule",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "direction",
						Usage:       "[Required] set target direction[send/receive]",
						Value:       "receive",
						Destination: &firewallUpdateParam.Direction,
					},
					&cli.IntFlag{
						Name:        "index",
						Usage:       "[Required] index of target static NAT",
						Destination: &firewallUpdateParam.Index,
					},
					&cli.StringFlag{
						Name:        "protocol",
						Usage:       "set target protocol",
						Destination: &firewallUpdateParam.Protocol,
					},
					&cli.StringFlag{
						Name:        "source-network",
						Usage:       "set source ipaddress or network address",
						Destination: &firewallUpdateParam.SourceNetwork,
					},
					&cli.IntFlag{
						Name:        "source-port",
						Usage:       "set source port",
						Destination: &firewallUpdateParam.SourcePort,
					},
					&cli.StringFlag{
						Name:        "destination-network",
						Aliases:     []string{"dest-network"},
						Usage:       "set destination ipaddress or network address",
						Destination: &firewallUpdateParam.DestinationNetwork,
					},
					&cli.IntFlag{
						Name:        "destination-port",
						Aliases:     []string{"dest-port"},
						Usage:       "set destination port",
						Destination: &firewallUpdateParam.DestinationPort,
					},
					&cli.StringFlag{
						Name:        "action",
						Usage:       "set action[allow/deny]",
						Value:       "deny",
						Destination: &firewallUpdateParam.Action,
					},
					&cli.BoolFlag{
						Name:        "enable-logging",
						Usage:       "enable logging",
						Destination: &firewallUpdateParam.EnableLogging,
					},
					&cli.StringFlag{
						Name:        "description",
						Aliases:     []string{"desc"},
						Usage:       "set description",
						Destination: &firewallUpdateParam.Description,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &firewallUpdateParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &firewallUpdateParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, firewallUpdateParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterFirewallUpdateCompleteArgs(ctx, firewallUpdateParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterFirewallUpdateCompleteArgs(ctx, firewallUpdateParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterFirewallUpdateCompleteFlags(ctx, firewallUpdateParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterFirewallUpdateCompleteArgs(ctx, firewallUpdateParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := firewallUpdateParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), firewallUpdateParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !firewallUpdateParam.Assumeyes && !command.ConfirmContinue("firewall-update", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						firewallUpdateParam.SetId(id)
						p := *firewallUpdateParam // copy struct value
						firewallUpdateParam := &p
						go func() {
							err := funcs.VPCRouterFirewallUpdate(ctx, firewallUpdateParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "firewall-delete",
				Usage:     "Delete firewall rule",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "direction",
						Usage:       "[Required] set target direction[send/receive]",
						Value:       "receive",
						Destination: &firewallDeleteParam.Direction,
					},
					&cli.IntFlag{
						Name:        "index",
						Usage:       "[Required] index of target static NAT",
						Destination: &firewallDeleteParam.Index,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &firewallDeleteParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &firewallDeleteParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, firewallDeleteParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterFirewallDeleteCompleteArgs(ctx, firewallDeleteParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterFirewallDeleteCompleteArgs(ctx, firewallDeleteParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterFirewallDeleteCompleteFlags(ctx, firewallDeleteParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterFirewallDeleteCompleteArgs(ctx, firewallDeleteParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := firewallDeleteParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), firewallDeleteParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !firewallDeleteParam.Assumeyes && !command.ConfirmContinue("firewall-delete", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						firewallDeleteParam.SetId(id)
						p := *firewallDeleteParam // copy struct value
						firewallDeleteParam := &p
						go func() {
							err := funcs.VPCRouterFirewallDelete(ctx, firewallDeleteParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "dhcp-server-info",
				Aliases:   []string{"dhcp-server-list"},
				Usage:     "Show information of DHCP servers",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "output-type",
						Aliases:     []string{"out"},
						Usage:       "Output type [json/csv/tsv]",
						Destination: &dhcpServerInfoParam.OutputType,
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:        "quiet",
						Aliases:     []string{"q"},
						Usage:       "Only display IDs",
						Destination: &dhcpServerInfoParam.Quiet,
					},
					&cli.StringFlag{
						Name:        "format",
						Aliases:     []string{"fmt"},
						Usage:       "Output format(see text/template package document for detail)",
						Destination: &dhcpServerInfoParam.Format,
					},
					&cli.StringFlag{
						Name:        "format-file",
						Usage:       "Output format from file(see text/template package document for detail)",
						Destination: &dhcpServerInfoParam.FormatFile,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &dhcpServerInfoParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, dhcpServerInfoParam)

					// Set option values for slice
					dhcpServerInfoParam.Column = c.StringSlice("column")

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterDhcpServerInfoCompleteArgs(ctx, dhcpServerInfoParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterDhcpServerInfoCompleteArgs(ctx, dhcpServerInfoParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterDhcpServerInfoCompleteFlags(ctx, dhcpServerInfoParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterDhcpServerInfoCompleteArgs(ctx, dhcpServerInfoParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Set option values for slice
					dhcpServerInfoParam.Column = c.StringSlice("column")

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := dhcpServerInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), dhcpServerInfoParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						dhcpServerInfoParam.SetId(id)
						p := *dhcpServerInfoParam // copy struct value
						dhcpServerInfoParam := &p
						go func() {
							err := funcs.VPCRouterDhcpServerInfo(ctx, dhcpServerInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "dhcp-server-add",
				Usage:     "Add DHCP server",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:        "index",
						Usage:       "[Required] set target NIC(private NIC index)",
						Destination: &dhcpServerAddParam.Index,
					},
					&cli.StringFlag{
						Name:        "range-start",
						Usage:       "[Required] set DHCP IPAddress Range(start)",
						Destination: &dhcpServerAddParam.RangeStart,
					},
					&cli.StringFlag{
						Name:        "range-stop",
						Aliases:     []string{"range-end"},
						Usage:       "[Required] set DHCP IPAddress Range(stop)",
						Destination: &dhcpServerAddParam.RangeStop,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &dhcpServerAddParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &dhcpServerAddParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, dhcpServerAddParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterDhcpServerAddCompleteArgs(ctx, dhcpServerAddParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterDhcpServerAddCompleteArgs(ctx, dhcpServerAddParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterDhcpServerAddCompleteFlags(ctx, dhcpServerAddParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterDhcpServerAddCompleteArgs(ctx, dhcpServerAddParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := dhcpServerAddParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), dhcpServerAddParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !dhcpServerAddParam.Assumeyes && !command.ConfirmContinue("dhcp-server-add", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						dhcpServerAddParam.SetId(id)
						p := *dhcpServerAddParam // copy struct value
						dhcpServerAddParam := &p
						go func() {
							err := funcs.VPCRouterDhcpServerAdd(ctx, dhcpServerAddParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "dhcp-server-update",
				Usage:     "Update DHCP server",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:        "index",
						Usage:       "[Required] set target NIC(private NIC index)",
						Destination: &dhcpServerUpdateParam.Index,
					},
					&cli.StringFlag{
						Name:        "range-start",
						Usage:       "set DHCP IPAddress Range(start)",
						Destination: &dhcpServerUpdateParam.RangeStart,
					},
					&cli.StringFlag{
						Name:        "range-stop",
						Aliases:     []string{"range-end"},
						Usage:       "set DHCP IPAddress Range(stop)",
						Destination: &dhcpServerUpdateParam.RangeStop,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &dhcpServerUpdateParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &dhcpServerUpdateParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, dhcpServerUpdateParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterDhcpServerUpdateCompleteArgs(ctx, dhcpServerUpdateParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterDhcpServerUpdateCompleteArgs(ctx, dhcpServerUpdateParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterDhcpServerUpdateCompleteFlags(ctx, dhcpServerUpdateParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterDhcpServerUpdateCompleteArgs(ctx, dhcpServerUpdateParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := dhcpServerUpdateParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), dhcpServerUpdateParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !dhcpServerUpdateParam.Assumeyes && !command.ConfirmContinue("dhcp-server-update", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						dhcpServerUpdateParam.SetId(id)
						p := *dhcpServerUpdateParam // copy struct value
						dhcpServerUpdateParam := &p
						go func() {
							err := funcs.VPCRouterDhcpServerUpdate(ctx, dhcpServerUpdateParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "dhcp-server-delete",
				Usage:     "Delete DHCP server",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:        "index",
						Usage:       "[Required] set target NIC(private NIC index)",
						Destination: &dhcpServerDeleteParam.Index,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &dhcpServerDeleteParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &dhcpServerDeleteParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, dhcpServerDeleteParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterDhcpServerDeleteCompleteArgs(ctx, dhcpServerDeleteParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterDhcpServerDeleteCompleteArgs(ctx, dhcpServerDeleteParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterDhcpServerDeleteCompleteFlags(ctx, dhcpServerDeleteParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterDhcpServerDeleteCompleteArgs(ctx, dhcpServerDeleteParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := dhcpServerDeleteParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), dhcpServerDeleteParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !dhcpServerDeleteParam.Assumeyes && !command.ConfirmContinue("dhcp-server-delete", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						dhcpServerDeleteParam.SetId(id)
						p := *dhcpServerDeleteParam // copy struct value
						dhcpServerDeleteParam := &p
						go func() {
							err := funcs.VPCRouterDhcpServerDelete(ctx, dhcpServerDeleteParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "dhcp-static-mapping-info",
				Aliases:   []string{"dhcp-static-mapping-list"},
				Usage:     "Show information of DHCP static mapping",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "output-type",
						Aliases:     []string{"out"},
						Usage:       "Output type [json/csv/tsv]",
						Destination: &dhcpStaticMappingInfoParam.OutputType,
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:        "quiet",
						Aliases:     []string{"q"},
						Usage:       "Only display IDs",
						Destination: &dhcpStaticMappingInfoParam.Quiet,
					},
					&cli.StringFlag{
						Name:        "format",
						Aliases:     []string{"fmt"},
						Usage:       "Output format(see text/template package document for detail)",
						Destination: &dhcpStaticMappingInfoParam.Format,
					},
					&cli.StringFlag{
						Name:        "format-file",
						Usage:       "Output format from file(see text/template package document for detail)",
						Destination: &dhcpStaticMappingInfoParam.FormatFile,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &dhcpStaticMappingInfoParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, dhcpStaticMappingInfoParam)

					// Set option values for slice
					dhcpStaticMappingInfoParam.Column = c.StringSlice("column")

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterDhcpStaticMappingInfoCompleteArgs(ctx, dhcpStaticMappingInfoParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterDhcpStaticMappingInfoCompleteArgs(ctx, dhcpStaticMappingInfoParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterDhcpStaticMappingInfoCompleteFlags(ctx, dhcpStaticMappingInfoParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterDhcpStaticMappingInfoCompleteArgs(ctx, dhcpStaticMappingInfoParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Set option values for slice
					dhcpStaticMappingInfoParam.Column = c.StringSlice("column")

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := dhcpStaticMappingInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), dhcpStaticMappingInfoParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						dhcpStaticMappingInfoParam.SetId(id)
						p := *dhcpStaticMappingInfoParam // copy struct value
						dhcpStaticMappingInfoParam := &p
						go func() {
							err := funcs.VPCRouterDhcpStaticMappingInfo(ctx, dhcpStaticMappingInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "dhcp-static-mapping-add",
				Usage:     "Add DHCP static mapping",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "macaddress",
						Aliases:     []string{"mac"},
						Usage:       "[Required] set mac address",
						Destination: &dhcpStaticMappingAddParam.Macaddress,
					},
					&cli.StringFlag{
						Name:        "ipaddress",
						Aliases:     []string{"ip"},
						Usage:       "[Required] set ipaddress",
						Destination: &dhcpStaticMappingAddParam.Ipaddress,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &dhcpStaticMappingAddParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &dhcpStaticMappingAddParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, dhcpStaticMappingAddParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterDhcpStaticMappingAddCompleteArgs(ctx, dhcpStaticMappingAddParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterDhcpStaticMappingAddCompleteArgs(ctx, dhcpStaticMappingAddParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterDhcpStaticMappingAddCompleteFlags(ctx, dhcpStaticMappingAddParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterDhcpStaticMappingAddCompleteArgs(ctx, dhcpStaticMappingAddParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := dhcpStaticMappingAddParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), dhcpStaticMappingAddParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !dhcpStaticMappingAddParam.Assumeyes && !command.ConfirmContinue("dhcp-static-mapping-add", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						dhcpStaticMappingAddParam.SetId(id)
						p := *dhcpStaticMappingAddParam // copy struct value
						dhcpStaticMappingAddParam := &p
						go func() {
							err := funcs.VPCRouterDhcpStaticMappingAdd(ctx, dhcpStaticMappingAddParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "dhcp-static-mapping-update",
				Usage:     "Update DHCP static mapping",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:        "index",
						Usage:       "[Required] index of target DHCP static mapping",
						Destination: &dhcpStaticMappingUpdateParam.Index,
					},
					&cli.StringFlag{
						Name:        "macaddress",
						Aliases:     []string{"mac"},
						Usage:       "set mac address",
						Destination: &dhcpStaticMappingUpdateParam.Macaddress,
					},
					&cli.StringFlag{
						Name:        "ipaddress",
						Aliases:     []string{"ip"},
						Usage:       "set ipaddress",
						Destination: &dhcpStaticMappingUpdateParam.Ipaddress,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &dhcpStaticMappingUpdateParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &dhcpStaticMappingUpdateParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, dhcpStaticMappingUpdateParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterDhcpStaticMappingUpdateCompleteArgs(ctx, dhcpStaticMappingUpdateParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterDhcpStaticMappingUpdateCompleteArgs(ctx, dhcpStaticMappingUpdateParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterDhcpStaticMappingUpdateCompleteFlags(ctx, dhcpStaticMappingUpdateParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterDhcpStaticMappingUpdateCompleteArgs(ctx, dhcpStaticMappingUpdateParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := dhcpStaticMappingUpdateParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), dhcpStaticMappingUpdateParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !dhcpStaticMappingUpdateParam.Assumeyes && !command.ConfirmContinue("dhcp-static-mapping-update", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						dhcpStaticMappingUpdateParam.SetId(id)
						p := *dhcpStaticMappingUpdateParam // copy struct value
						dhcpStaticMappingUpdateParam := &p
						go func() {
							err := funcs.VPCRouterDhcpStaticMappingUpdate(ctx, dhcpStaticMappingUpdateParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "dhcp-static-mapping-delete",
				Usage:     "Delete DHCP static mapping",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:        "index",
						Usage:       "[Required] index of target DHCP static mapping",
						Destination: &dhcpStaticMappingDeleteParam.Index,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &dhcpStaticMappingDeleteParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &dhcpStaticMappingDeleteParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, dhcpStaticMappingDeleteParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterDhcpStaticMappingDeleteCompleteArgs(ctx, dhcpStaticMappingDeleteParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterDhcpStaticMappingDeleteCompleteArgs(ctx, dhcpStaticMappingDeleteParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterDhcpStaticMappingDeleteCompleteFlags(ctx, dhcpStaticMappingDeleteParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterDhcpStaticMappingDeleteCompleteArgs(ctx, dhcpStaticMappingDeleteParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := dhcpStaticMappingDeleteParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), dhcpStaticMappingDeleteParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !dhcpStaticMappingDeleteParam.Assumeyes && !command.ConfirmContinue("dhcp-static-mapping-delete", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						dhcpStaticMappingDeleteParam.SetId(id)
						p := *dhcpStaticMappingDeleteParam // copy struct value
						dhcpStaticMappingDeleteParam := &p
						go func() {
							err := funcs.VPCRouterDhcpStaticMappingDelete(ctx, dhcpStaticMappingDeleteParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "pptp-server-info",
				Usage:     "Show information of PPTP server",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "output-type",
						Aliases:     []string{"out"},
						Usage:       "Output type [json/csv/tsv]",
						Destination: &pptpServerInfoParam.OutputType,
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:        "quiet",
						Aliases:     []string{"q"},
						Usage:       "Only display IDs",
						Destination: &pptpServerInfoParam.Quiet,
					},
					&cli.StringFlag{
						Name:        "format",
						Aliases:     []string{"fmt"},
						Usage:       "Output format(see text/template package document for detail)",
						Destination: &pptpServerInfoParam.Format,
					},
					&cli.StringFlag{
						Name:        "format-file",
						Usage:       "Output format from file(see text/template package document for detail)",
						Destination: &pptpServerInfoParam.FormatFile,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &pptpServerInfoParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, pptpServerInfoParam)

					// Set option values for slice
					pptpServerInfoParam.Column = c.StringSlice("column")

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterPptpServerInfoCompleteArgs(ctx, pptpServerInfoParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterPptpServerInfoCompleteArgs(ctx, pptpServerInfoParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterPptpServerInfoCompleteFlags(ctx, pptpServerInfoParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterPptpServerInfoCompleteArgs(ctx, pptpServerInfoParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Set option values for slice
					pptpServerInfoParam.Column = c.StringSlice("column")

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := pptpServerInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), pptpServerInfoParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						pptpServerInfoParam.SetId(id)
						p := *pptpServerInfoParam // copy struct value
						pptpServerInfoParam := &p
						go func() {
							err := funcs.VPCRouterPptpServerInfo(ctx, pptpServerInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "pptp-server-update",
				Usage:     "Update PPTP server setting",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "enabled",
						Usage:       "[Required] enable/disable PPTP server",
						Destination: &pptpServerUpdateParam.Enabled,
					},
					&cli.StringFlag{
						Name:        "range-start",
						Usage:       "set IPAddress Range(start)",
						Destination: &pptpServerUpdateParam.RangeStart,
					},
					&cli.StringFlag{
						Name:        "range-stop",
						Aliases:     []string{"range-end"},
						Usage:       "set IPAddress Range(stop)",
						Destination: &pptpServerUpdateParam.RangeStop,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &pptpServerUpdateParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &pptpServerUpdateParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, pptpServerUpdateParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterPptpServerUpdateCompleteArgs(ctx, pptpServerUpdateParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterPptpServerUpdateCompleteArgs(ctx, pptpServerUpdateParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterPptpServerUpdateCompleteFlags(ctx, pptpServerUpdateParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterPptpServerUpdateCompleteArgs(ctx, pptpServerUpdateParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := pptpServerUpdateParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), pptpServerUpdateParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !pptpServerUpdateParam.Assumeyes && !command.ConfirmContinue("pptp-server-update", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						pptpServerUpdateParam.SetId(id)
						p := *pptpServerUpdateParam // copy struct value
						pptpServerUpdateParam := &p
						go func() {
							err := funcs.VPCRouterPptpServerUpdate(ctx, pptpServerUpdateParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "l2tp-server-info",
				Usage:     "Show information of L2TP/IPSec server",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "output-type",
						Aliases:     []string{"out"},
						Usage:       "Output type [json/csv/tsv]",
						Destination: &l2tpServerInfoParam.OutputType,
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:        "quiet",
						Aliases:     []string{"q"},
						Usage:       "Only display IDs",
						Destination: &l2tpServerInfoParam.Quiet,
					},
					&cli.StringFlag{
						Name:        "format",
						Aliases:     []string{"fmt"},
						Usage:       "Output format(see text/template package document for detail)",
						Destination: &l2tpServerInfoParam.Format,
					},
					&cli.StringFlag{
						Name:        "format-file",
						Usage:       "Output format from file(see text/template package document for detail)",
						Destination: &l2tpServerInfoParam.FormatFile,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &l2tpServerInfoParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, l2tpServerInfoParam)

					// Set option values for slice
					l2tpServerInfoParam.Column = c.StringSlice("column")

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterL2tpServerInfoCompleteArgs(ctx, l2tpServerInfoParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterL2tpServerInfoCompleteArgs(ctx, l2tpServerInfoParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterL2tpServerInfoCompleteFlags(ctx, l2tpServerInfoParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterL2tpServerInfoCompleteArgs(ctx, l2tpServerInfoParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Set option values for slice
					l2tpServerInfoParam.Column = c.StringSlice("column")

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := l2tpServerInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), l2tpServerInfoParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						l2tpServerInfoParam.SetId(id)
						p := *l2tpServerInfoParam // copy struct value
						l2tpServerInfoParam := &p
						go func() {
							err := funcs.VPCRouterL2tpServerInfo(ctx, l2tpServerInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "l2tp-server-update",
				Usage:     "Update L2TP/IPSec server setting",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "enabled",
						Usage:       "[Required] enable/disable PPTP server",
						Destination: &l2tpServerUpdateParam.Enabled,
					},
					&cli.StringFlag{
						Name:        "range-start",
						Usage:       "set IPAddress Range(start)",
						Destination: &l2tpServerUpdateParam.RangeStart,
					},
					&cli.StringFlag{
						Name:        "range-stop",
						Aliases:     []string{"range-end"},
						Usage:       "set IPAddress Range(stop)",
						Destination: &l2tpServerUpdateParam.RangeStop,
					},
					&cli.StringFlag{
						Name:        "pre-shared-secret",
						Usage:       "set PreSharedSecret",
						Destination: &l2tpServerUpdateParam.PreSharedSecret,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &l2tpServerUpdateParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &l2tpServerUpdateParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, l2tpServerUpdateParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterL2tpServerUpdateCompleteArgs(ctx, l2tpServerUpdateParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterL2tpServerUpdateCompleteArgs(ctx, l2tpServerUpdateParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterL2tpServerUpdateCompleteFlags(ctx, l2tpServerUpdateParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterL2tpServerUpdateCompleteArgs(ctx, l2tpServerUpdateParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := l2tpServerUpdateParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), l2tpServerUpdateParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !l2tpServerUpdateParam.Assumeyes && !command.ConfirmContinue("l2tp-server-update", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						l2tpServerUpdateParam.SetId(id)
						p := *l2tpServerUpdateParam // copy struct value
						l2tpServerUpdateParam := &p
						go func() {
							err := funcs.VPCRouterL2tpServerUpdate(ctx, l2tpServerUpdateParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "user-info",
				Aliases:   []string{"user-list"},
				Usage:     "Show information of remote-access users",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "output-type",
						Aliases:     []string{"out"},
						Usage:       "Output type [json/csv/tsv]",
						Destination: &userInfoParam.OutputType,
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:        "quiet",
						Aliases:     []string{"q"},
						Usage:       "Only display IDs",
						Destination: &userInfoParam.Quiet,
					},
					&cli.StringFlag{
						Name:        "format",
						Aliases:     []string{"fmt"},
						Usage:       "Output format(see text/template package document for detail)",
						Destination: &userInfoParam.Format,
					},
					&cli.StringFlag{
						Name:        "format-file",
						Usage:       "Output format from file(see text/template package document for detail)",
						Destination: &userInfoParam.FormatFile,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &userInfoParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, userInfoParam)

					// Set option values for slice
					userInfoParam.Column = c.StringSlice("column")

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterUserInfoCompleteArgs(ctx, userInfoParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterUserInfoCompleteArgs(ctx, userInfoParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterUserInfoCompleteFlags(ctx, userInfoParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterUserInfoCompleteArgs(ctx, userInfoParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Set option values for slice
					userInfoParam.Column = c.StringSlice("column")

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := userInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), userInfoParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						userInfoParam.SetId(id)
						p := *userInfoParam // copy struct value
						userInfoParam := &p
						go func() {
							err := funcs.VPCRouterUserInfo(ctx, userInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "user-add",
				Usage:     "Add remote-access user",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "username",
						Aliases:     []string{"user"},
						Usage:       "[Required] set remote-access username",
						Destination: &userAddParam.Username,
					},
					&cli.StringFlag{
						Name:        "password",
						Aliases:     []string{"pass"},
						Usage:       "[Required] set remote-access password",
						Destination: &userAddParam.Password,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &userAddParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &userAddParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, userAddParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterUserAddCompleteArgs(ctx, userAddParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterUserAddCompleteArgs(ctx, userAddParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterUserAddCompleteFlags(ctx, userAddParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterUserAddCompleteArgs(ctx, userAddParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := userAddParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), userAddParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !userAddParam.Assumeyes && !command.ConfirmContinue("user-add", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						userAddParam.SetId(id)
						p := *userAddParam // copy struct value
						userAddParam := &p
						go func() {
							err := funcs.VPCRouterUserAdd(ctx, userAddParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "user-update",
				Usage:     "Update remote-access user",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:        "index",
						Usage:       "[Required] index of target remote-access user",
						Destination: &userUpdateParam.Index,
					},
					&cli.StringFlag{
						Name:        "username",
						Aliases:     []string{"user"},
						Usage:       "set remote-access username",
						Destination: &userUpdateParam.Username,
					},
					&cli.StringFlag{
						Name:        "password",
						Aliases:     []string{"pass"},
						Usage:       "set remote-access password",
						Destination: &userUpdateParam.Password,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &userUpdateParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &userUpdateParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, userUpdateParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterUserUpdateCompleteArgs(ctx, userUpdateParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterUserUpdateCompleteArgs(ctx, userUpdateParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterUserUpdateCompleteFlags(ctx, userUpdateParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterUserUpdateCompleteArgs(ctx, userUpdateParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := userUpdateParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), userUpdateParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !userUpdateParam.Assumeyes && !command.ConfirmContinue("user-update", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						userUpdateParam.SetId(id)
						p := *userUpdateParam // copy struct value
						userUpdateParam := &p
						go func() {
							err := funcs.VPCRouterUserUpdate(ctx, userUpdateParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "user-delete",
				Usage:     "Delete remote-access user",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:        "index",
						Usage:       "[Required] index of target remote-access user",
						Destination: &userDeleteParam.Index,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &userDeleteParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &userDeleteParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, userDeleteParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterUserDeleteCompleteArgs(ctx, userDeleteParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterUserDeleteCompleteArgs(ctx, userDeleteParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterUserDeleteCompleteFlags(ctx, userDeleteParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterUserDeleteCompleteArgs(ctx, userDeleteParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := userDeleteParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), userDeleteParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !userDeleteParam.Assumeyes && !command.ConfirmContinue("user-delete", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						userDeleteParam.SetId(id)
						p := *userDeleteParam // copy struct value
						userDeleteParam := &p
						go func() {
							err := funcs.VPCRouterUserDelete(ctx, userDeleteParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "site-to-site-vpn-info",
				Aliases:   []string{"site-to-site-vpn-list"},
				Usage:     "Show information of site-to-site IPSec VPN settings",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "output-type",
						Aliases:     []string{"out"},
						Usage:       "Output type [json/csv/tsv]",
						Destination: &siteToSiteVpnInfoParam.OutputType,
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:        "quiet",
						Aliases:     []string{"q"},
						Usage:       "Only display IDs",
						Destination: &siteToSiteVpnInfoParam.Quiet,
					},
					&cli.StringFlag{
						Name:        "format",
						Aliases:     []string{"fmt"},
						Usage:       "Output format(see text/template package document for detail)",
						Destination: &siteToSiteVpnInfoParam.Format,
					},
					&cli.StringFlag{
						Name:        "format-file",
						Usage:       "Output format from file(see text/template package document for detail)",
						Destination: &siteToSiteVpnInfoParam.FormatFile,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &siteToSiteVpnInfoParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, siteToSiteVpnInfoParam)

					// Set option values for slice
					siteToSiteVpnInfoParam.Column = c.StringSlice("column")

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterSiteToSiteVpnInfoCompleteArgs(ctx, siteToSiteVpnInfoParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterSiteToSiteVpnInfoCompleteArgs(ctx, siteToSiteVpnInfoParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterSiteToSiteVpnInfoCompleteFlags(ctx, siteToSiteVpnInfoParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterSiteToSiteVpnInfoCompleteArgs(ctx, siteToSiteVpnInfoParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Set option values for slice
					siteToSiteVpnInfoParam.Column = c.StringSlice("column")

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := siteToSiteVpnInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), siteToSiteVpnInfoParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						siteToSiteVpnInfoParam.SetId(id)
						p := *siteToSiteVpnInfoParam // copy struct value
						siteToSiteVpnInfoParam := &p
						go func() {
							err := funcs.VPCRouterSiteToSiteVpnInfo(ctx, siteToSiteVpnInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "site-to-site-vpn-add",
				Usage:     "Add site-to-site IPSec VPN setting",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "peer",
						Usage:       "[Required] set peer address",
						Destination: &siteToSiteVpnAddParam.Peer,
					},
					&cli.StringFlag{
						Name:        "remote-id",
						Usage:       "[Required] set remote-id",
						Destination: &siteToSiteVpnAddParam.RemoteId,
					},
					&cli.StringFlag{
						Name:        "pre-shared-secret",
						Usage:       "[Required] set pre-shared-secret",
						Destination: &siteToSiteVpnAddParam.PreSharedSecret,
					},
					&cli.StringSliceFlag{
						Name:  "routes",
						Usage: "[Required] set route list",
					},
					&cli.StringSliceFlag{
						Name:  "local-prefix",
						Usage: "[Required] set local prefix list",
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &siteToSiteVpnAddParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &siteToSiteVpnAddParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, siteToSiteVpnAddParam)

					// Set option values for slice
					siteToSiteVpnAddParam.Routes = c.StringSlice("routes")
					siteToSiteVpnAddParam.LocalPrefix = c.StringSlice("local-prefix")

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterSiteToSiteVpnAddCompleteArgs(ctx, siteToSiteVpnAddParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterSiteToSiteVpnAddCompleteArgs(ctx, siteToSiteVpnAddParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterSiteToSiteVpnAddCompleteFlags(ctx, siteToSiteVpnAddParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterSiteToSiteVpnAddCompleteArgs(ctx, siteToSiteVpnAddParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Set option values for slice
					siteToSiteVpnAddParam.Routes = c.StringSlice("routes")
					siteToSiteVpnAddParam.LocalPrefix = c.StringSlice("local-prefix")

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := siteToSiteVpnAddParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), siteToSiteVpnAddParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !siteToSiteVpnAddParam.Assumeyes && !command.ConfirmContinue("site-to-site-vpn-add", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						siteToSiteVpnAddParam.SetId(id)
						p := *siteToSiteVpnAddParam // copy struct value
						siteToSiteVpnAddParam := &p
						go func() {
							err := funcs.VPCRouterSiteToSiteVpnAdd(ctx, siteToSiteVpnAddParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "site-to-site-vpn-update",
				Usage:     "Update site-to-site IPSec VPN setting",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:        "index",
						Usage:       "[Required] index of target remote-access user",
						Destination: &siteToSiteVpnUpdateParam.Index,
					},
					&cli.StringFlag{
						Name:        "peer",
						Usage:       "set peer address",
						Destination: &siteToSiteVpnUpdateParam.Peer,
					},
					&cli.StringFlag{
						Name:        "remote-id",
						Usage:       "set remote-id",
						Destination: &siteToSiteVpnUpdateParam.RemoteId,
					},
					&cli.StringFlag{
						Name:        "pre-shared-secret",
						Usage:       "set pre-shared-secret",
						Destination: &siteToSiteVpnUpdateParam.PreSharedSecret,
					},
					&cli.StringSliceFlag{
						Name:  "routes",
						Usage: "set route list",
					},
					&cli.StringSliceFlag{
						Name:  "local-prefix",
						Usage: "set local prefix list",
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &siteToSiteVpnUpdateParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &siteToSiteVpnUpdateParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, siteToSiteVpnUpdateParam)

					// Set option values for slice
					siteToSiteVpnUpdateParam.Routes = c.StringSlice("routes")
					siteToSiteVpnUpdateParam.LocalPrefix = c.StringSlice("local-prefix")

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterSiteToSiteVpnUpdateCompleteArgs(ctx, siteToSiteVpnUpdateParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterSiteToSiteVpnUpdateCompleteArgs(ctx, siteToSiteVpnUpdateParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterSiteToSiteVpnUpdateCompleteFlags(ctx, siteToSiteVpnUpdateParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterSiteToSiteVpnUpdateCompleteArgs(ctx, siteToSiteVpnUpdateParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Set option values for slice
					siteToSiteVpnUpdateParam.Routes = c.StringSlice("routes")
					siteToSiteVpnUpdateParam.LocalPrefix = c.StringSlice("local-prefix")

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := siteToSiteVpnUpdateParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), siteToSiteVpnUpdateParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !siteToSiteVpnUpdateParam.Assumeyes && !command.ConfirmContinue("site-to-site-vpn-update", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						siteToSiteVpnUpdateParam.SetId(id)
						p := *siteToSiteVpnUpdateParam // copy struct value
						siteToSiteVpnUpdateParam := &p
						go func() {
							err := funcs.VPCRouterSiteToSiteVpnUpdate(ctx, siteToSiteVpnUpdateParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "site-to-site-vpn-delete",
				Usage:     "Delete site-to-site IPSec VPN setting",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:        "index",
						Usage:       "[Required] index of target remote-access user",
						Destination: &siteToSiteVpnDeleteParam.Index,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &siteToSiteVpnDeleteParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &siteToSiteVpnDeleteParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, siteToSiteVpnDeleteParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterSiteToSiteVpnDeleteCompleteArgs(ctx, siteToSiteVpnDeleteParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterSiteToSiteVpnDeleteCompleteArgs(ctx, siteToSiteVpnDeleteParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterSiteToSiteVpnDeleteCompleteFlags(ctx, siteToSiteVpnDeleteParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterSiteToSiteVpnDeleteCompleteArgs(ctx, siteToSiteVpnDeleteParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := siteToSiteVpnDeleteParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), siteToSiteVpnDeleteParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !siteToSiteVpnDeleteParam.Assumeyes && !command.ConfirmContinue("site-to-site-vpn-delete", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						siteToSiteVpnDeleteParam.SetId(id)
						p := *siteToSiteVpnDeleteParam // copy struct value
						siteToSiteVpnDeleteParam := &p
						go func() {
							err := funcs.VPCRouterSiteToSiteVpnDelete(ctx, siteToSiteVpnDeleteParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "static-route-info",
				Aliases:   []string{"static-route-list"},
				Usage:     "Show information of static-routes",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "output-type",
						Aliases:     []string{"out"},
						Usage:       "Output type [json/csv/tsv]",
						Destination: &staticRouteInfoParam.OutputType,
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:        "quiet",
						Aliases:     []string{"q"},
						Usage:       "Only display IDs",
						Destination: &staticRouteInfoParam.Quiet,
					},
					&cli.StringFlag{
						Name:        "format",
						Aliases:     []string{"fmt"},
						Usage:       "Output format(see text/template package document for detail)",
						Destination: &staticRouteInfoParam.Format,
					},
					&cli.StringFlag{
						Name:        "format-file",
						Usage:       "Output format from file(see text/template package document for detail)",
						Destination: &staticRouteInfoParam.FormatFile,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &staticRouteInfoParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, staticRouteInfoParam)

					// Set option values for slice
					staticRouteInfoParam.Column = c.StringSlice("column")

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterStaticRouteInfoCompleteArgs(ctx, staticRouteInfoParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterStaticRouteInfoCompleteArgs(ctx, staticRouteInfoParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterStaticRouteInfoCompleteFlags(ctx, staticRouteInfoParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterStaticRouteInfoCompleteArgs(ctx, staticRouteInfoParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Set option values for slice
					staticRouteInfoParam.Column = c.StringSlice("column")

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := staticRouteInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), staticRouteInfoParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						staticRouteInfoParam.SetId(id)
						p := *staticRouteInfoParam // copy struct value
						staticRouteInfoParam := &p
						go func() {
							err := funcs.VPCRouterStaticRouteInfo(ctx, staticRouteInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "static-route-add",
				Usage:     "Add static-route",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "prefix",
						Usage:       "[Required] set prefix",
						Destination: &staticRouteAddParam.Prefix,
					},
					&cli.StringFlag{
						Name:        "next-hop",
						Usage:       "[Required] set next-hop",
						Destination: &staticRouteAddParam.NextHop,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &staticRouteAddParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &staticRouteAddParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, staticRouteAddParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterStaticRouteAddCompleteArgs(ctx, staticRouteAddParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterStaticRouteAddCompleteArgs(ctx, staticRouteAddParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterStaticRouteAddCompleteFlags(ctx, staticRouteAddParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterStaticRouteAddCompleteArgs(ctx, staticRouteAddParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := staticRouteAddParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), staticRouteAddParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !staticRouteAddParam.Assumeyes && !command.ConfirmContinue("static-route-add", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						staticRouteAddParam.SetId(id)
						p := *staticRouteAddParam // copy struct value
						staticRouteAddParam := &p
						go func() {
							err := funcs.VPCRouterStaticRouteAdd(ctx, staticRouteAddParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "static-route-update",
				Usage:     "Update static-route",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:        "index",
						Usage:       "[Required] index of target static-route",
						Destination: &staticRouteUpdateParam.Index,
					},
					&cli.StringFlag{
						Name:        "prefix",
						Usage:       "set prefix",
						Destination: &staticRouteUpdateParam.Prefix,
					},
					&cli.StringFlag{
						Name:        "next-hop",
						Usage:       "set next-hop",
						Destination: &staticRouteUpdateParam.NextHop,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &staticRouteUpdateParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &staticRouteUpdateParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, staticRouteUpdateParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterStaticRouteUpdateCompleteArgs(ctx, staticRouteUpdateParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterStaticRouteUpdateCompleteArgs(ctx, staticRouteUpdateParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterStaticRouteUpdateCompleteFlags(ctx, staticRouteUpdateParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterStaticRouteUpdateCompleteArgs(ctx, staticRouteUpdateParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := staticRouteUpdateParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), staticRouteUpdateParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !staticRouteUpdateParam.Assumeyes && !command.ConfirmContinue("static-route-update", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						staticRouteUpdateParam.SetId(id)
						p := *staticRouteUpdateParam // copy struct value
						staticRouteUpdateParam := &p
						go func() {
							err := funcs.VPCRouterStaticRouteUpdate(ctx, staticRouteUpdateParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "static-route-delete",
				Usage:     "Delete static-route",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:        "index",
						Usage:       "[Required] index of target static-route",
						Destination: &staticRouteDeleteParam.Index,
					},
					&cli.BoolFlag{
						Name:        "assumeyes",
						Aliases:     []string{"y"},
						Usage:       "assume that the answer to any question which would be asked is yes",
						Destination: &staticRouteDeleteParam.Assumeyes,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &staticRouteDeleteParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, staticRouteDeleteParam)

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterStaticRouteDeleteCompleteArgs(ctx, staticRouteDeleteParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterStaticRouteDeleteCompleteArgs(ctx, staticRouteDeleteParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterStaticRouteDeleteCompleteFlags(ctx, staticRouteDeleteParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterStaticRouteDeleteCompleteArgs(ctx, staticRouteDeleteParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := staticRouteDeleteParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), staticRouteDeleteParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !staticRouteDeleteParam.Assumeyes && !command.ConfirmContinue("static-route-delete", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						staticRouteDeleteParam.SetId(id)
						p := *staticRouteDeleteParam // copy struct value
						staticRouteDeleteParam := &p
						go func() {
							err := funcs.VPCRouterStaticRouteDelete(ctx, staticRouteDeleteParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "monitor",
				Usage:     "Monitor VPCRouter",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "index",
						Usage:       "[Required] index of target interface",
						Value:       "0",
						Destination: &monitorParam.Index,
					},
					&cli.StringFlag{
						Name:        "start",
						Usage:       "set start-time",
						Destination: &monitorParam.Start,
					},
					&cli.StringFlag{
						Name:        "end",
						Usage:       "set end-time",
						Destination: &monitorParam.End,
					},
					&cli.StringFlag{
						Name:        "key-format",
						Usage:       "[Required] set monitoring value key-format",
						Value:       "sakuracloud.{{.ID}}.vpcrouter",
						Destination: &monitorParam.KeyFormat,
					},
					&cli.StringFlag{
						Name:        "output-type",
						Aliases:     []string{"out"},
						Usage:       "Output type [json/csv/tsv]",
						Destination: &monitorParam.OutputType,
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:        "quiet",
						Aliases:     []string{"q"},
						Usage:       "Only display IDs",
						Destination: &monitorParam.Quiet,
					},
					&cli.StringFlag{
						Name:        "format",
						Aliases:     []string{"fmt"},
						Usage:       "Output format(see text/template package document for detail)",
						Destination: &monitorParam.Format,
					},
					&cli.StringFlag{
						Name:        "format-file",
						Usage:       "Output format from file(see text/template package document for detail)",
						Destination: &monitorParam.FormatFile,
					},
					&cli.Int64Flag{
						Name:        "id",
						Usage:       "set target ID",
						Destination: &monitorParam.Id,
						Hidden:      true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, monitorParam)

					// Set option values for slice
					monitorParam.Column = c.StringSlice("column")

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterMonitorCompleteArgs(ctx, monitorParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterMonitorCompleteArgs(ctx, monitorParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterMonitorCompleteFlags(ctx, monitorParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterMonitorCompleteArgs(ctx, monitorParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					// Set option values for slice
					monitorParam.Column = c.StringSlice("column")

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Validate specific for each command params
					if errors := monitorParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), monitorParam)

					if c.NArg() == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}
					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					for _, arg := range c.Args().Slice() {
						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.VPCRouters {
									ids = append(ids, v.GetID())
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("ID or Name argument is required")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						monitorParam.SetId(id)
						p := *monitorParam // copy struct value
						monitorParam := &p
						go func() {
							err := funcs.VPCRouterMonitor(ctx, monitorParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
		},
	}

	// build Category-Resource mapping
	AppendResourceCategoryMap("vpc-router", &schema.Category{
		Key:         "appliance",
		DisplayName: "Appliance",
		Order:       40,
	})

	// build Category-Command mapping

	AppendCommandCategoryMap("vpc-router", "boot", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})
	AppendCommandCategoryMap("vpc-router", "create", &schema.Category{
		Key:         "basics",
		DisplayName: "Basics",
		Order:       10,
	})
	AppendCommandCategoryMap("vpc-router", "delete", &schema.Category{
		Key:         "basics",
		DisplayName: "Basics",
		Order:       10,
	})
	AppendCommandCategoryMap("vpc-router", "dhcp-server-add", &schema.Category{
		Key:         "dhcp-server",
		DisplayName: "DHCP Server Management",
		Order:       60,
	})
	AppendCommandCategoryMap("vpc-router", "dhcp-server-delete", &schema.Category{
		Key:         "dhcp-server",
		DisplayName: "DHCP Server Management",
		Order:       60,
	})
	AppendCommandCategoryMap("vpc-router", "dhcp-server-info", &schema.Category{
		Key:         "dhcp-server",
		DisplayName: "DHCP Server Management",
		Order:       60,
	})
	AppendCommandCategoryMap("vpc-router", "dhcp-server-update", &schema.Category{
		Key:         "dhcp-server",
		DisplayName: "DHCP Server Management",
		Order:       60,
	})
	AppendCommandCategoryMap("vpc-router", "dhcp-static-mapping-add", &schema.Category{
		Key:         "dhcp-static-mapping",
		DisplayName: "DHCP Static Map Setting Management",
		Order:       65,
	})
	AppendCommandCategoryMap("vpc-router", "dhcp-static-mapping-delete", &schema.Category{
		Key:         "dhcp-static-mapping",
		DisplayName: "DHCP Static Map Setting Management",
		Order:       65,
	})
	AppendCommandCategoryMap("vpc-router", "dhcp-static-mapping-info", &schema.Category{
		Key:         "dhcp-static-mapping",
		DisplayName: "DHCP Static Map Setting Management",
		Order:       65,
	})
	AppendCommandCategoryMap("vpc-router", "dhcp-static-mapping-update", &schema.Category{
		Key:         "dhcp-static-mapping",
		DisplayName: "DHCP Static Map Setting Management",
		Order:       65,
	})
	AppendCommandCategoryMap("vpc-router", "firewall-add", &schema.Category{
		Key:         "fw",
		DisplayName: "Firewall Setting Management",
		Order:       50,
	})
	AppendCommandCategoryMap("vpc-router", "firewall-delete", &schema.Category{
		Key:         "fw",
		DisplayName: "Firewall Setting Management",
		Order:       50,
	})
	AppendCommandCategoryMap("vpc-router", "firewall-info", &schema.Category{
		Key:         "fw",
		DisplayName: "Firewall Setting Management",
		Order:       50,
	})
	AppendCommandCategoryMap("vpc-router", "firewall-update", &schema.Category{
		Key:         "fw",
		DisplayName: "Firewall Setting Management",
		Order:       50,
	})
	AppendCommandCategoryMap("vpc-router", "interface-connect", &schema.Category{
		Key:         "nic",
		DisplayName: "Network Interface Management",
		Order:       30,
	})
	AppendCommandCategoryMap("vpc-router", "interface-disconnect", &schema.Category{
		Key:         "nic",
		DisplayName: "Network Interface Management",
		Order:       30,
	})
	AppendCommandCategoryMap("vpc-router", "interface-info", &schema.Category{
		Key:         "nic",
		DisplayName: "Network Interface Management",
		Order:       30,
	})
	AppendCommandCategoryMap("vpc-router", "interface-update", &schema.Category{
		Key:         "nic",
		DisplayName: "Network Interface Management",
		Order:       30,
	})
	AppendCommandCategoryMap("vpc-router", "l2tp-server-info", &schema.Category{
		Key:         "remote-access",
		DisplayName: "RemoteAccess(VPN) Setting Management",
		Order:       70,
	})
	AppendCommandCategoryMap("vpc-router", "l2tp-server-update", &schema.Category{
		Key:         "remote-access",
		DisplayName: "RemoteAccess(VPN) Setting Management",
		Order:       70,
	})
	AppendCommandCategoryMap("vpc-router", "list", &schema.Category{
		Key:         "basics",
		DisplayName: "Basics",
		Order:       10,
	})
	AppendCommandCategoryMap("vpc-router", "monitor", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitoring",
		Order:       500,
	})
	AppendCommandCategoryMap("vpc-router", "port-forwarding-add", &schema.Category{
		Key:         "rnat",
		DisplayName: "Port Forward Setting Management",
		Order:       45,
	})
	AppendCommandCategoryMap("vpc-router", "port-forwarding-delete", &schema.Category{
		Key:         "rnat",
		DisplayName: "Port Forward Setting Management",
		Order:       45,
	})
	AppendCommandCategoryMap("vpc-router", "port-forwarding-info", &schema.Category{
		Key:         "rnat",
		DisplayName: "Port Forward Setting Management",
		Order:       45,
	})
	AppendCommandCategoryMap("vpc-router", "port-forwarding-update", &schema.Category{
		Key:         "rnat",
		DisplayName: "Port Forward Setting Management",
		Order:       45,
	})
	AppendCommandCategoryMap("vpc-router", "pptp-server-info", &schema.Category{
		Key:         "remote-access",
		DisplayName: "RemoteAccess(VPN) Setting Management",
		Order:       70,
	})
	AppendCommandCategoryMap("vpc-router", "pptp-server-update", &schema.Category{
		Key:         "remote-access",
		DisplayName: "RemoteAccess(VPN) Setting Management",
		Order:       70,
	})
	AppendCommandCategoryMap("vpc-router", "read", &schema.Category{
		Key:         "basics",
		DisplayName: "Basics",
		Order:       10,
	})
	AppendCommandCategoryMap("vpc-router", "reset", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})
	AppendCommandCategoryMap("vpc-router", "shutdown", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})
	AppendCommandCategoryMap("vpc-router", "shutdown-force", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})
	AppendCommandCategoryMap("vpc-router", "site-to-site-vpn-add", &schema.Category{
		Key:         "s2s",
		DisplayName: "Site to Site IPSec VPN Management",
		Order:       80,
	})
	AppendCommandCategoryMap("vpc-router", "site-to-site-vpn-delete", &schema.Category{
		Key:         "s2s",
		DisplayName: "Site to Site IPSec VPN Management",
		Order:       80,
	})
	AppendCommandCategoryMap("vpc-router", "site-to-site-vpn-info", &schema.Category{
		Key:         "s2s",
		DisplayName: "Site to Site IPSec VPN Management",
		Order:       80,
	})
	AppendCommandCategoryMap("vpc-router", "site-to-site-vpn-update", &schema.Category{
		Key:         "s2s",
		DisplayName: "Site to Site IPSec VPN Management",
		Order:       80,
	})
	AppendCommandCategoryMap("vpc-router", "static-nat-add", &schema.Category{
		Key:         "snat",
		DisplayName: "Static NAT Setting Management",
		Order:       40,
	})
	AppendCommandCategoryMap("vpc-router", "static-nat-delete", &schema.Category{
		Key:         "snat",
		DisplayName: "Static NAT Setting Management",
		Order:       40,
	})
	AppendCommandCategoryMap("vpc-router", "static-nat-info", &schema.Category{
		Key:         "snat",
		DisplayName: "Static NAT Setting Management",
		Order:       40,
	})
	AppendCommandCategoryMap("vpc-router", "static-nat-update", &schema.Category{
		Key:         "snat",
		DisplayName: "Static NAT Setting Management",
		Order:       40,
	})
	AppendCommandCategoryMap("vpc-router", "static-route-add", &schema.Category{
		Key:         "routing",
		DisplayName: "Static Route Management",
		Order:       90,
	})
	AppendCommandCategoryMap("vpc-router", "static-route-delete", &schema.Category{
		Key:         "routing",
		DisplayName: "Static Route Management",
		Order:       90,
	})
	AppendCommandCategoryMap("vpc-router", "static-route-info", &schema.Category{
		Key:         "routing",
		DisplayName: "Static Route Management",
		Order:       90,
	})
	AppendCommandCategoryMap("vpc-router", "static-route-update", &schema.Category{
		Key:         "routing",
		DisplayName: "Static Route Management",
		Order:       90,
	})
	AppendCommandCategoryMap("vpc-router", "update", &schema.Category{
		Key:         "basics",
		DisplayName: "Basics",
		Order:       10,
	})
	AppendCommandCategoryMap("vpc-router", "user-add", &schema.Category{
		Key:         "remote-access",
		DisplayName: "RemoteAccess(VPN) Setting Management",
		Order:       70,
	})
	AppendCommandCategoryMap("vpc-router", "user-delete", &schema.Category{
		Key:         "remote-access",
		DisplayName: "RemoteAccess(VPN) Setting Management",
		Order:       70,
	})
	AppendCommandCategoryMap("vpc-router", "user-info", &schema.Category{
		Key:         "remote-access",
		DisplayName: "RemoteAccess(VPN) Setting Management",
		Order:       70,
	})
	AppendCommandCategoryMap("vpc-router", "user-update", &schema.Category{
		Key:         "remote-access",
		DisplayName: "RemoteAccess(VPN) Setting Management",
		Order:       70,
	})
	AppendCommandCategoryMap("vpc-router", "wait-for-boot", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})
	AppendCommandCategoryMap("vpc-router", "wait-for-down", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})

	// build Category-Param mapping

	AppendFlagCategoryMap("vpc-router", "boot", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "boot", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "create", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "create", "boot-after-create", &schema.Category{
		Key:         "operation",
		DisplayName: "Operation options",
		Order:       30,
	})
	AppendFlagCategoryMap("vpc-router", "create", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "create", "description", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("vpc-router", "create", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "create", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "create", "icon-id", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("vpc-router", "create", "ipaddress1", &schema.Category{
		Key:         "network",
		DisplayName: "Network options",
		Order:       20,
	})
	AppendFlagCategoryMap("vpc-router", "create", "ipaddress2", &schema.Category{
		Key:         "network",
		DisplayName: "Network options",
		Order:       20,
	})
	AppendFlagCategoryMap("vpc-router", "create", "name", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("vpc-router", "create", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "create", "plan", &schema.Category{
		Key:         "router",
		DisplayName: "VPCRouter options",
		Order:       10,
	})
	AppendFlagCategoryMap("vpc-router", "create", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "create", "switch-id", &schema.Category{
		Key:         "router",
		DisplayName: "VPCRouter options",
		Order:       10,
	})
	AppendFlagCategoryMap("vpc-router", "create", "tags", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("vpc-router", "create", "vip", &schema.Category{
		Key:         "network",
		DisplayName: "Network options",
		Order:       20,
	})
	AppendFlagCategoryMap("vpc-router", "create", "vrid", &schema.Category{
		Key:         "router",
		DisplayName: "VPCRouter options",
		Order:       10,
	})
	AppendFlagCategoryMap("vpc-router", "delete", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "delete", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "delete", "force", &schema.Category{
		Key:         "router",
		DisplayName: "VPCRouter options",
		Order:       10,
	})
	AppendFlagCategoryMap("vpc-router", "delete", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "delete", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "delete", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "delete", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "delete", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-add", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-add", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-add", "index", &schema.Category{
		Key:         "DHCP-Server",
		DisplayName: "DHCP-Server options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-add", "range-start", &schema.Category{
		Key:         "DHCP-Server",
		DisplayName: "DHCP-Server options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-add", "range-stop", &schema.Category{
		Key:         "DHCP-Server",
		DisplayName: "DHCP-Server options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-delete", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-delete", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-delete", "index", &schema.Category{
		Key:         "DHCP-Server",
		DisplayName: "DHCP-Server options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-update", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-update", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-update", "index", &schema.Category{
		Key:         "DHCP-Server",
		DisplayName: "DHCP-Server options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-update", "range-start", &schema.Category{
		Key:         "DHCP-Server",
		DisplayName: "DHCP-Server options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-update", "range-stop", &schema.Category{
		Key:         "DHCP-Server",
		DisplayName: "DHCP-Server options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-add", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-add", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-add", "ipaddress", &schema.Category{
		Key:         "DHCP-Static-Mapping",
		DisplayName: "DHCP-Static-Mapping options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-add", "macaddress", &schema.Category{
		Key:         "DHCP-Static-Mapping",
		DisplayName: "DHCP-Static-Mapping options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-delete", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-delete", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-delete", "index", &schema.Category{
		Key:         "DHCP-Static-Mapping",
		DisplayName: "DHCP-Static-Mapping options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-update", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-update", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-update", "index", &schema.Category{
		Key:         "DHCP-Static-Mapping",
		DisplayName: "DHCP-Static-Mapping options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-update", "ipaddress", &schema.Category{
		Key:         "DHCP-Static-Mapping",
		DisplayName: "DHCP-Static-Mapping options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-update", "macaddress", &schema.Category{
		Key:         "DHCP-Static-Mapping",
		DisplayName: "DHCP-Static-Mapping options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-add", "action", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-add", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-add", "description", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-add", "destination-network", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-add", "destination-port", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-add", "direction", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-add", "enable-logging", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-add", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-add", "protocol", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-add", "source-network", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-add", "source-port", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-delete", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-delete", "direction", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-delete", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-delete", "index", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-info", "direction", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-update", "action", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-update", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-update", "description", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-update", "destination-network", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-update", "destination-port", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-update", "direction", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-update", "enable-logging", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-update", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-update", "index", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-update", "protocol", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-update", "source-network", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-update", "source-port", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "interface-connect", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "interface-connect", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "interface-connect", "index", &schema.Category{
		Key:         "interface",
		DisplayName: "Interface options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "interface-connect", "ipaddress", &schema.Category{
		Key:         "network",
		DisplayName: "Network options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "interface-connect", "ipaddress1", &schema.Category{
		Key:         "network",
		DisplayName: "Network options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "interface-connect", "ipaddress2", &schema.Category{
		Key:         "network",
		DisplayName: "Network options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "interface-connect", "nw-masklen", &schema.Category{
		Key:         "network",
		DisplayName: "Network options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "interface-connect", "switch-id", &schema.Category{
		Key:         "interface",
		DisplayName: "Interface options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "interface-connect", "with-reboot", &schema.Category{
		Key:         "operation",
		DisplayName: "Operation options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "interface-disconnect", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "interface-disconnect", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "interface-disconnect", "index", &schema.Category{
		Key:         "interface",
		DisplayName: "Interface options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "interface-disconnect", "with-reboot", &schema.Category{
		Key:         "operation",
		DisplayName: "Operation options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "interface-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "interface-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "interface-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "interface-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "interface-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "interface-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "interface-update", "alias", &schema.Category{
		Key:         "network",
		DisplayName: "Network options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "interface-update", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "interface-update", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "interface-update", "index", &schema.Category{
		Key:         "interface",
		DisplayName: "Interface options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "interface-update", "ipaddress", &schema.Category{
		Key:         "network",
		DisplayName: "Network options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "interface-update", "ipaddress1", &schema.Category{
		Key:         "network",
		DisplayName: "Network options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "interface-update", "ipaddress2", &schema.Category{
		Key:         "network",
		DisplayName: "Network options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "interface-update", "nw-masklen", &schema.Category{
		Key:         "network",
		DisplayName: "Network options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "interface-update", "switch-id", &schema.Category{
		Key:         "interface",
		DisplayName: "Interface options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "interface-update", "with-reboot", &schema.Category{
		Key:         "operation",
		DisplayName: "Operation options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "l2tp-server-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "l2tp-server-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "l2tp-server-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "l2tp-server-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "l2tp-server-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "l2tp-server-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "l2tp-server-update", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "l2tp-server-update", "enabled", &schema.Category{
		Key:         "L2TP-IPSec",
		DisplayName: "L2TP-IPSec options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "l2tp-server-update", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "l2tp-server-update", "pre-shared-secret", &schema.Category{
		Key:         "L2TP-IPSec",
		DisplayName: "L2TP-IPSec options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "l2tp-server-update", "range-start", &schema.Category{
		Key:         "L2TP-IPSec",
		DisplayName: "L2TP-IPSec options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "l2tp-server-update", "range-stop", &schema.Category{
		Key:         "L2TP-IPSec",
		DisplayName: "L2TP-IPSec options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "list", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "list", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "list", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "list", "from", &schema.Category{
		Key:         "limit-offset",
		DisplayName: "Limit/Offset options",
		Order:       2147483597,
	})
	AppendFlagCategoryMap("vpc-router", "list", "id", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "list", "max", &schema.Category{
		Key:         "limit-offset",
		DisplayName: "Limit/Offset options",
		Order:       2147483597,
	})
	AppendFlagCategoryMap("vpc-router", "list", "name", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "list", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "list", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "list", "sort", &schema.Category{
		Key:         "sort",
		DisplayName: "Sort options",
		Order:       2147483607,
	})
	AppendFlagCategoryMap("vpc-router", "list", "tags", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "monitor", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "monitor", "end", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "monitor", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "monitor", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "monitor", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "monitor", "index", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "monitor", "key-format", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "monitor", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "monitor", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "monitor", "start", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-add", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-add", "description", &schema.Category{
		Key:         "Port-Forwarding",
		DisplayName: "Port-Forwarding options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-add", "global-port", &schema.Category{
		Key:         "Port-Forwarding",
		DisplayName: "Port-Forwarding options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-add", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-add", "private-ipaddress", &schema.Category{
		Key:         "Port-Forwarding",
		DisplayName: "Port-Forwarding options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-add", "private-port", &schema.Category{
		Key:         "Port-Forwarding",
		DisplayName: "Port-Forwarding options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-add", "protocol", &schema.Category{
		Key:         "Port-Forwarding",
		DisplayName: "Port-Forwarding options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-delete", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-delete", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-delete", "index", &schema.Category{
		Key:         "Port-Forwarding",
		DisplayName: "Port-Forwarding options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-update", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-update", "description", &schema.Category{
		Key:         "Port-Forwarding",
		DisplayName: "Port-Forwarding options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-update", "global-port", &schema.Category{
		Key:         "Port-Forwarding",
		DisplayName: "Port-Forwarding options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-update", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-update", "index", &schema.Category{
		Key:         "Port-Forwarding",
		DisplayName: "Port-Forwarding options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-update", "private-ipaddress", &schema.Category{
		Key:         "Port-Forwarding",
		DisplayName: "Port-Forwarding options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-update", "private-port", &schema.Category{
		Key:         "Port-Forwarding",
		DisplayName: "Port-Forwarding options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-update", "protocol", &schema.Category{
		Key:         "Port-Forwarding",
		DisplayName: "Port-Forwarding options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "pptp-server-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "pptp-server-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "pptp-server-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "pptp-server-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "pptp-server-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "pptp-server-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "pptp-server-update", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "pptp-server-update", "enabled", &schema.Category{
		Key:         "PPTP",
		DisplayName: "PPTP options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "pptp-server-update", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "pptp-server-update", "range-start", &schema.Category{
		Key:         "PPTP",
		DisplayName: "PPTP options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "pptp-server-update", "range-stop", &schema.Category{
		Key:         "PPTP",
		DisplayName: "PPTP options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "read", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "read", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "read", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "read", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "read", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "read", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "reset", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "reset", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "shutdown", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "shutdown", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "shutdown-force", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "shutdown-force", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-add", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-add", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-add", "local-prefix", &schema.Category{
		Key:         "Site-To-Site IPSec VPN",
		DisplayName: "Site-To-Site IPSec VPN options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-add", "peer", &schema.Category{
		Key:         "Site-To-Site IPSec VPN",
		DisplayName: "Site-To-Site IPSec VPN options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-add", "pre-shared-secret", &schema.Category{
		Key:         "Site-To-Site IPSec VPN",
		DisplayName: "Site-To-Site IPSec VPN options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-add", "remote-id", &schema.Category{
		Key:         "Site-To-Site IPSec VPN",
		DisplayName: "Site-To-Site IPSec VPN options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-add", "routes", &schema.Category{
		Key:         "Site-To-Site IPSec VPN",
		DisplayName: "Site-To-Site IPSec VPN options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-delete", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-delete", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-delete", "index", &schema.Category{
		Key:         "Site-To-Site IPSec VPN",
		DisplayName: "Site-To-Site IPSec VPN options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-update", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-update", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-update", "index", &schema.Category{
		Key:         "Site-To-Site IPSec VPN",
		DisplayName: "Site-To-Site IPSec VPN options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-update", "local-prefix", &schema.Category{
		Key:         "Site-To-Site IPSec VPN",
		DisplayName: "Site-To-Site IPSec VPN options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-update", "peer", &schema.Category{
		Key:         "Site-To-Site IPSec VPN",
		DisplayName: "Site-To-Site IPSec VPN options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-update", "pre-shared-secret", &schema.Category{
		Key:         "Site-To-Site IPSec VPN",
		DisplayName: "Site-To-Site IPSec VPN options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-update", "remote-id", &schema.Category{
		Key:         "Site-To-Site IPSec VPN",
		DisplayName: "Site-To-Site IPSec VPN options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-update", "routes", &schema.Category{
		Key:         "Site-To-Site IPSec VPN",
		DisplayName: "Site-To-Site IPSec VPN options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-add", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-add", "description", &schema.Category{
		Key:         "Static-NAT",
		DisplayName: "Static-NAT options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-add", "global", &schema.Category{
		Key:         "Static-NAT",
		DisplayName: "Static-NAT options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-add", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-add", "private", &schema.Category{
		Key:         "Static-NAT",
		DisplayName: "Static-NAT options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-delete", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-delete", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-delete", "index", &schema.Category{
		Key:         "Static-NAT",
		DisplayName: "Static-NAT options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-update", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-update", "description", &schema.Category{
		Key:         "Static-NAT",
		DisplayName: "Static-NAT options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-update", "global", &schema.Category{
		Key:         "Static-NAT",
		DisplayName: "Static-NAT options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-update", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-update", "index", &schema.Category{
		Key:         "Static-NAT",
		DisplayName: "Static-NAT options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-update", "private", &schema.Category{
		Key:         "Static-NAT",
		DisplayName: "Static-NAT options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-add", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-add", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-add", "next-hop", &schema.Category{
		Key:         "Static-Route",
		DisplayName: "Static-Route options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-add", "prefix", &schema.Category{
		Key:         "Static-Route",
		DisplayName: "Static-Route options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-delete", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-delete", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-delete", "index", &schema.Category{
		Key:         "Static-Route",
		DisplayName: "Static-Route options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-update", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-update", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-update", "index", &schema.Category{
		Key:         "Static-Route",
		DisplayName: "Static-Route options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-update", "next-hop", &schema.Category{
		Key:         "Static-Route",
		DisplayName: "Static-Route options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-update", "prefix", &schema.Category{
		Key:         "Static-Route",
		DisplayName: "Static-Route options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "update", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "update", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "update", "description", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("vpc-router", "update", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "update", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "update", "icon-id", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("vpc-router", "update", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "update", "name", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("vpc-router", "update", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "update", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "update", "syslog-host", &schema.Category{
		Key:         "router",
		DisplayName: "VPCRouter options",
		Order:       10,
	})
	AppendFlagCategoryMap("vpc-router", "update", "tags", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("vpc-router", "user-add", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "user-add", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "user-add", "password", &schema.Category{
		Key:         "user",
		DisplayName: "User options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "user-add", "username", &schema.Category{
		Key:         "user",
		DisplayName: "User options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "user-delete", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "user-delete", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "user-delete", "index", &schema.Category{
		Key:         "user",
		DisplayName: "User options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "user-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "user-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "user-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "user-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "user-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "user-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "user-update", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "user-update", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "user-update", "index", &schema.Category{
		Key:         "user",
		DisplayName: "User options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "user-update", "password", &schema.Category{
		Key:         "user",
		DisplayName: "User options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "user-update", "username", &schema.Category{
		Key:         "user",
		DisplayName: "User options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "wait-for-boot", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "wait-for-down", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})

	// append command to GlobalContext
	Commands = append(Commands, cliCommand)
}
